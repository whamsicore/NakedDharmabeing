{"version":3,"sources":["../src/components/copilot-provider/copilotkit.tsx"],"sourcesContent":["\"use client\";\n\nimport { FunctionDefinition } from \"@copilotkit/shared\";\nimport { useCallback, useState } from \"react\";\nimport { CopilotContext, CopilotApiConfig } from \"../../context/copilot-context\";\nimport useTree from \"../../hooks/use-tree\";\nimport { DocumentPointer } from \"../../types\";\nimport {\n  FunctionCallHandler,\n  AnnotatedFunction,\n  annotatedFunctionToChatCompletionFunction,\n} from \"@copilotkit/shared\";\nimport useFlatCategoryStore from \"../../hooks/use-flat-category-store\";\nimport { StandardCopilotApiConfig } from \"./standard-copilot-api-config\";\nimport { CopilotKitProps } from \"./copilotkit-props\";\nimport { ToolDefinition } from \"@copilotkit/shared\";\n\n/**\n * The CopilotKit component.\n * This component provides the Copilot context to its children.\n * It can be configured either with a chat API endpoint or a CopilotApiConfig.\n *\n * NOTE: The backend can use OpenAI, or you can bring your own LLM.\n * For examples of the backend api implementation, see `examples/next-openai` usage (under `src/api/copilotkit`),\n * or read the documentation at https://docs.copilotkit.ai\n * In particular, Getting-Started > Quickstart-Backend: https://docs.copilotkit.ai/getting-started/quickstart-backend\n *\n * Example usage:\n * ```\n * <CopilotKit url=\"https://your.copilotkit.api\">\n *    <App />\n * </CopilotKit>\n * ```\n *\n * or\n *\n * ```\n * const copilotApiConfig = new StandardCopilotApiConfig(\n *  \"https://your.copilotkit.api/v1\",\n *  \"https://your.copilotkit.api/v2\",\n *  {},\n *  {}\n *  );\n *\n * // ...\n *\n * <CopilotKit chatApiConfig={copilotApiConfig}>\n *    <App />\n * </CopilotKit>\n * ```\n *\n * @param props - The props for the component.\n * @returns The CopilotKit component.\n */\nexport function CopilotKit({ children, ...props }: CopilotKitProps) {\n  // Compute all the functions and properties that we need to pass\n  // to the CopilotContext.\n\n  const [entryPoints, setEntryPoints] = useState<Record<string, AnnotatedFunction<any[]>>>({});\n\n  const { addElement, removeElement, printTree } = useTree();\n\n  const {\n    addElement: addDocument,\n    removeElement: removeDocument,\n    allElements: allDocuments,\n  } = useFlatCategoryStore<DocumentPointer>();\n\n  const setEntryPoint = useCallback((id: string, entryPoint: AnnotatedFunction<any[]>) => {\n    setEntryPoints((prevPoints) => {\n      return {\n        ...prevPoints,\n        [id]: entryPoint,\n      };\n    });\n  }, []);\n\n  const removeEntryPoint = useCallback((id: string) => {\n    setEntryPoints((prevPoints) => {\n      const newPoints = { ...prevPoints };\n      delete newPoints[id];\n      return newPoints;\n    });\n  }, []);\n\n  const getContextString = useCallback(\n    (documents: DocumentPointer[], categories: string[]) => {\n      const documentsString = documents\n        .map((document) => {\n          return `${document.name} (${document.sourceApplication}):\\n${document.getContents()}`;\n        })\n        .join(\"\\n\\n\");\n\n      const nonDocumentStrings = printTree(categories);\n\n      return `${documentsString}\\n\\n${nonDocumentStrings}`;\n    },\n    [printTree],\n  );\n\n  const addContext = useCallback(\n    (\n      context: string,\n      parentId?: string,\n      categories: string[] = defaultCopilotContextCategories,\n    ) => {\n      return addElement(context, categories, parentId);\n    },\n    [addElement],\n  );\n\n  const removeContext = useCallback(\n    (id: string) => {\n      removeElement(id);\n    },\n    [removeElement],\n  );\n\n  const getChatCompletionFunctionDescriptions = useCallback(\n    (customEntryPoints?: Record<string, AnnotatedFunction<any[]>>) => {\n      return entryPointsToChatCompletionFunctions(Object.values(customEntryPoints || entryPoints));\n    },\n    [entryPoints],\n  );\n\n  const getFunctionCallHandler = useCallback(\n    (customEntryPoints?: Record<string, AnnotatedFunction<any[]>>) => {\n      return entryPointsToFunctionCallHandler(Object.values(customEntryPoints || entryPoints));\n    },\n    [entryPoints],\n  );\n\n  const getDocumentsContext = useCallback(\n    (categories: string[]) => {\n      return allDocuments(categories);\n    },\n    [allDocuments],\n  );\n\n  const addDocumentContext = useCallback(\n    (documentPointer: DocumentPointer, categories: string[] = defaultCopilotContextCategories) => {\n      return addDocument(documentPointer, categories);\n    },\n    [addDocument],\n  );\n\n  const removeDocumentContext = useCallback(\n    (documentId: string) => {\n      removeDocument(documentId);\n    },\n    [removeDocument],\n  );\n\n  // get the appropriate CopilotApiConfig from the props\n  const copilotApiConfig: CopilotApiConfig = new StandardCopilotApiConfig(\n    props.url,\n    `${props.url}/v2`,\n    props.headers || {},\n    {\n      ...props.body,\n      ...props.backendOnlyProps,\n    },\n  );\n\n  return (\n    <CopilotContext.Provider\n      value={{\n        entryPoints,\n        getChatCompletionFunctionDescriptions,\n        getFunctionCallHandler,\n        setEntryPoint,\n        removeEntryPoint,\n        getContextString,\n        addContext,\n        removeContext,\n        getDocumentsContext,\n        addDocumentContext,\n        removeDocumentContext,\n        copilotApiConfig: copilotApiConfig,\n      }}\n    >\n      {children}\n    </CopilotContext.Provider>\n  );\n}\n\nexport const defaultCopilotContextCategories = [\"global\"];\n\nfunction entryPointsToFunctionCallHandler(\n  entryPoints: AnnotatedFunction<any[]>[],\n): FunctionCallHandler {\n  return async (chatMessages, functionCall) => {\n    let entrypointsByFunctionName: Record<string, AnnotatedFunction<any[]>> = {};\n    for (let entryPoint of entryPoints) {\n      entrypointsByFunctionName[entryPoint.name] = entryPoint;\n    }\n\n    const entryPointFunction = entrypointsByFunctionName[functionCall.name || \"\"];\n    if (entryPointFunction) {\n      let functionCallArguments: Record<string, any>[] = [];\n      if (functionCall.arguments) {\n        functionCallArguments = JSON.parse(functionCall.arguments);\n      }\n\n      const paramsInCorrectOrder: any[] = [];\n      for (let arg of entryPointFunction.argumentAnnotations) {\n        paramsInCorrectOrder.push(\n          functionCallArguments[arg.name as keyof typeof functionCallArguments],\n        );\n      }\n\n      await entryPointFunction.implementation(...paramsInCorrectOrder);\n\n      // commented out becasue for now we don't want to return anything\n      // const result = await entryPointFunction.implementation(\n      //   ...parsedFunctionCallArguments\n      // );\n      // const functionResponse: ChatRequest = {\n      //   messages: [\n      //     ...chatMessages,\n      //     {\n      //       id: nanoid(),\n      //       name: functionCall.name,\n      //       role: 'function' as const,\n      //       content: JSON.stringify(result),\n      //     },\n      //   ],\n      // };\n\n      // return functionResponse;\n    }\n  };\n}\n\nfunction entryPointsToChatCompletionFunctions(\n  entryPoints: AnnotatedFunction<any[]>[],\n): ToolDefinition[] {\n  return entryPoints.map(annotatedFunctionToChatCompletionFunction);\n}\n"],"mappings":"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","names":[]}