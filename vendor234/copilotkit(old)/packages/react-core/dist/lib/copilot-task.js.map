{"version":3,"sources":["../../src/lib/copilot-task.ts","../../src/components/copilot-provider/copilotkit.tsx","../../src/utils/fetch-chat-completion.ts"],"sourcesContent":["import { AnnotatedFunction, FunctionCall, Message } from \"@copilotkit/shared\";\nimport { CopilotContextParams } from \"../context\";\nimport { defaultCopilotContextCategories } from \"../components\";\nimport { fetchAndDecodeChatCompletion } from \"../utils/fetch-chat-completion\";\n\nexport interface CopilotTaskConfig {\n  /**\n   * The instructions to be given to the assistant.\n   */\n  instructions: string;\n  /**\n   * Action definitions to be sent to the API.\n   */\n  actions?: AnnotatedFunction<any[]>[];\n  /**\n   * Whether to include the copilot readable context in the task.\n   */\n  includeCopilotReadable?: boolean;\n\n  /**\n   * Whether to include actions defined via useMakeCopilotActionable in the task.\n   */\n  includeCopilotActionable?: boolean;\n}\n\nexport class CopilotTask<T = any> {\n  private instructions: string;\n  private functions: AnnotatedFunction<any[]>[];\n  private includeCopilotReadable: boolean;\n  private includeCopilotActionable: boolean;\n\n  constructor(config: CopilotTaskConfig) {\n    this.instructions = config.instructions;\n    this.functions = config.actions || [];\n    this.includeCopilotReadable = config.includeCopilotReadable || true;\n    this.includeCopilotActionable = config.includeCopilotActionable || true;\n  }\n\n  async run(context: CopilotContextParams, data?: T): Promise<void> {\n    const entryPoints = this.includeCopilotActionable ? Object.assign({}, context.entryPoints) : {};\n\n    // merge functions into entry points\n    for (const fn of this.functions) {\n      entryPoints[fn.name] = fn;\n    }\n\n    let contextString = \"\";\n\n    if (data) {\n      contextString = (typeof data === \"string\" ? data : JSON.stringify(data)) + \"\\n\\n\";\n    }\n\n    if (this.includeCopilotReadable) {\n      contextString += context.getContextString([], defaultCopilotContextCategories);\n    }\n\n    const systemMessage: Message = {\n      id: \"system\",\n      content: taskSystemMessage(contextString, this.instructions),\n      role: \"system\",\n    };\n\n    const messages = [systemMessage];\n\n    const response = await fetchAndDecodeChatCompletion({\n      copilotConfig: context.copilotApiConfig,\n      messages: messages,\n      tools: context.getChatCompletionFunctionDescriptions(entryPoints),\n      headers: context.copilotApiConfig.headers,\n      body: context.copilotApiConfig.body,\n    });\n\n    if (!response.events) {\n      throw new Error(\"Failed to execute task\");\n    }\n\n    const reader = response.events.getReader();\n    let functionCalls: FunctionCall[] = [];\n\n    while (true) {\n      const { done, value } = await reader.read();\n\n      if (done) {\n        break;\n      }\n\n      if (value.type === \"function\") {\n        functionCalls.push({\n          name: value.name,\n          arguments: JSON.stringify(value.arguments),\n        });\n        break;\n      }\n    }\n\n    if (!functionCalls.length) {\n      throw new Error(\"No function call occurred\");\n    }\n\n    const functionCallHandler = context.getFunctionCallHandler(entryPoints);\n    for (const functionCall of functionCalls) {\n      await functionCallHandler(messages, functionCall);\n    }\n  }\n}\n\nfunction taskSystemMessage(contextString: string, instructions: string): string {\n  return `\nPlease act as an efficient, competent, conscientious, and industrious professional assistant.\n\nHelp the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.\nAlways be polite and respectful, and prefer brevity over verbosity.\n\nThe user has provided you with the following context:\n\\`\\`\\`\n${contextString}\n\\`\\`\\`\n\nThey have also provided you with functions you can call to initiate actions on their behalf.\n\nPlease assist them as best you can.\n\nThis is not a conversation, so please do not ask questions. Just call a function without saying anything else.\n\nThe user has given you the following task to complete:\n\n\\`\\`\\`\n${instructions}\n\\`\\`\\`\n`;\n}\n","\"use client\";\n\nimport { FunctionDefinition } from \"@copilotkit/shared\";\nimport { useCallback, useState } from \"react\";\nimport { CopilotContext, CopilotApiConfig } from \"../../context/copilot-context\";\nimport useTree from \"../../hooks/use-tree\";\nimport { DocumentPointer } from \"../../types\";\nimport {\n  FunctionCallHandler,\n  AnnotatedFunction,\n  annotatedFunctionToChatCompletionFunction,\n} from \"@copilotkit/shared\";\nimport useFlatCategoryStore from \"../../hooks/use-flat-category-store\";\nimport { StandardCopilotApiConfig } from \"./standard-copilot-api-config\";\nimport { CopilotKitProps } from \"./copilotkit-props\";\nimport { ToolDefinition } from \"@copilotkit/shared\";\n\n/**\n * The CopilotKit component.\n * This component provides the Copilot context to its children.\n * It can be configured either with a chat API endpoint or a CopilotApiConfig.\n *\n * NOTE: The backend can use OpenAI, or you can bring your own LLM.\n * For examples of the backend api implementation, see `examples/next-openai` usage (under `src/api/copilotkit`),\n * or read the documentation at https://docs.copilotkit.ai\n * In particular, Getting-Started > Quickstart-Backend: https://docs.copilotkit.ai/getting-started/quickstart-backend\n *\n * Example usage:\n * ```\n * <CopilotKit url=\"https://your.copilotkit.api\">\n *    <App />\n * </CopilotKit>\n * ```\n *\n * or\n *\n * ```\n * const copilotApiConfig = new StandardCopilotApiConfig(\n *  \"https://your.copilotkit.api/v1\",\n *  \"https://your.copilotkit.api/v2\",\n *  {},\n *  {}\n *  );\n *\n * // ...\n *\n * <CopilotKit chatApiConfig={copilotApiConfig}>\n *    <App />\n * </CopilotKit>\n * ```\n *\n * @param props - The props for the component.\n * @returns The CopilotKit component.\n */\nexport function CopilotKit({ children, ...props }: CopilotKitProps) {\n  // Compute all the functions and properties that we need to pass\n  // to the CopilotContext.\n\n  const [entryPoints, setEntryPoints] = useState<Record<string, AnnotatedFunction<any[]>>>({});\n\n  const { addElement, removeElement, printTree } = useTree();\n\n  const {\n    addElement: addDocument,\n    removeElement: removeDocument,\n    allElements: allDocuments,\n  } = useFlatCategoryStore<DocumentPointer>();\n\n  const setEntryPoint = useCallback((id: string, entryPoint: AnnotatedFunction<any[]>) => {\n    setEntryPoints((prevPoints) => {\n      return {\n        ...prevPoints,\n        [id]: entryPoint,\n      };\n    });\n  }, []);\n\n  const removeEntryPoint = useCallback((id: string) => {\n    setEntryPoints((prevPoints) => {\n      const newPoints = { ...prevPoints };\n      delete newPoints[id];\n      return newPoints;\n    });\n  }, []);\n\n  const getContextString = useCallback(\n    (documents: DocumentPointer[], categories: string[]) => {\n      const documentsString = documents\n        .map((document) => {\n          return `${document.name} (${document.sourceApplication}):\\n${document.getContents()}`;\n        })\n        .join(\"\\n\\n\");\n\n      const nonDocumentStrings = printTree(categories);\n\n      return `${documentsString}\\n\\n${nonDocumentStrings}`;\n    },\n    [printTree],\n  );\n\n  const addContext = useCallback(\n    (\n      context: string,\n      parentId?: string,\n      categories: string[] = defaultCopilotContextCategories,\n    ) => {\n      return addElement(context, categories, parentId);\n    },\n    [addElement],\n  );\n\n  const removeContext = useCallback(\n    (id: string) => {\n      removeElement(id);\n    },\n    [removeElement],\n  );\n\n  const getChatCompletionFunctionDescriptions = useCallback(\n    (customEntryPoints?: Record<string, AnnotatedFunction<any[]>>) => {\n      return entryPointsToChatCompletionFunctions(Object.values(customEntryPoints || entryPoints));\n    },\n    [entryPoints],\n  );\n\n  const getFunctionCallHandler = useCallback(\n    (customEntryPoints?: Record<string, AnnotatedFunction<any[]>>) => {\n      return entryPointsToFunctionCallHandler(Object.values(customEntryPoints || entryPoints));\n    },\n    [entryPoints],\n  );\n\n  const getDocumentsContext = useCallback(\n    (categories: string[]) => {\n      return allDocuments(categories);\n    },\n    [allDocuments],\n  );\n\n  const addDocumentContext = useCallback(\n    (documentPointer: DocumentPointer, categories: string[] = defaultCopilotContextCategories) => {\n      return addDocument(documentPointer, categories);\n    },\n    [addDocument],\n  );\n\n  const removeDocumentContext = useCallback(\n    (documentId: string) => {\n      removeDocument(documentId);\n    },\n    [removeDocument],\n  );\n\n  // get the appropriate CopilotApiConfig from the props\n  const copilotApiConfig: CopilotApiConfig = new StandardCopilotApiConfig(\n    props.url,\n    `${props.url}/v2`,\n    props.headers || {},\n    {\n      ...props.body,\n      ...props.backendOnlyProps,\n    },\n  );\n\n  return (\n    <CopilotContext.Provider\n      value={{\n        entryPoints,\n        getChatCompletionFunctionDescriptions,\n        getFunctionCallHandler,\n        setEntryPoint,\n        removeEntryPoint,\n        getContextString,\n        addContext,\n        removeContext,\n        getDocumentsContext,\n        addDocumentContext,\n        removeDocumentContext,\n        copilotApiConfig: copilotApiConfig,\n      }}\n    >\n      {children}\n    </CopilotContext.Provider>\n  );\n}\n\nexport const defaultCopilotContextCategories = [\"global\"];\n\nfunction entryPointsToFunctionCallHandler(\n  entryPoints: AnnotatedFunction<any[]>[],\n): FunctionCallHandler {\n  return async (chatMessages, functionCall) => {\n    let entrypointsByFunctionName: Record<string, AnnotatedFunction<any[]>> = {};\n    for (let entryPoint of entryPoints) {\n      entrypointsByFunctionName[entryPoint.name] = entryPoint;\n    }\n\n    const entryPointFunction = entrypointsByFunctionName[functionCall.name || \"\"];\n    if (entryPointFunction) {\n      let functionCallArguments: Record<string, any>[] = [];\n      if (functionCall.arguments) {\n        functionCallArguments = JSON.parse(functionCall.arguments);\n      }\n\n      const paramsInCorrectOrder: any[] = [];\n      for (let arg of entryPointFunction.argumentAnnotations) {\n        paramsInCorrectOrder.push(\n          functionCallArguments[arg.name as keyof typeof functionCallArguments],\n        );\n      }\n\n      await entryPointFunction.implementation(...paramsInCorrectOrder);\n\n      // commented out becasue for now we don't want to return anything\n      // const result = await entryPointFunction.implementation(\n      //   ...parsedFunctionCallArguments\n      // );\n      // const functionResponse: ChatRequest = {\n      //   messages: [\n      //     ...chatMessages,\n      //     {\n      //       id: nanoid(),\n      //       name: functionCall.name,\n      //       role: 'function' as const,\n      //       content: JSON.stringify(result),\n      //     },\n      //   ],\n      // };\n\n      // return functionResponse;\n    }\n  };\n}\n\nfunction entryPointsToChatCompletionFunctions(\n  entryPoints: AnnotatedFunction<any[]>[],\n): ToolDefinition[] {\n  return entryPoints.map(annotatedFunctionToChatCompletionFunction);\n}\n","import {\n  Message,\n  ToolDefinition,\n  ChatCompletionEvent,\n  decodeChatCompletion,\n  parseChatCompletion,\n  decodeChatCompletionAsText,\n  EXCLUDE_FROM_FORWARD_PROPS_KEYS,\n} from \"@copilotkit/shared\";\nimport { CopilotApiConfig } from \"../context\";\n\nexport interface FetchChatCompletionParams {\n  copilotConfig: CopilotApiConfig;\n  model?: string;\n  messages: Message[];\n  tools?: ToolDefinition[];\n  temperature?: number;\n  maxTokens?: number;\n  headers?: Record<string, string> | Headers;\n  body?: object;\n  signal?: AbortSignal;\n}\n\nexport async function fetchChatCompletion({\n  copilotConfig,\n  model,\n  messages,\n  tools,\n  temperature,\n  headers,\n  body,\n  signal,\n}: FetchChatCompletionParams): Promise<Response> {\n  temperature ||= 0.5;\n  tools ||= [];\n\n  // clean up any extra properties from messages\n  const cleanedMessages = messages.map((message) => {\n    const { content, role, name, function_call } = message;\n    return { content, role, name, function_call };\n  });\n\n  const response = await fetch(copilotConfig.chatApiEndpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...copilotConfig.headers,\n      ...(headers ? { ...headers } : {}),\n    },\n    body: JSON.stringify({\n      model,\n      messages: cleanedMessages,\n      stream: true,\n      ...(tools.length ? { tools } : {}),\n      ...(temperature ? { temperature } : {}),\n      ...(tools.length != 0 ? { tool_choice: \"auto\" } : {}),\n      ...copilotConfig.body,\n      ...copilotConfig.backendOnlyProps,\n      ...(Object.keys(copilotConfig[\"body\"] ?? {}).length > 0\n        ? { [EXCLUDE_FROM_FORWARD_PROPS_KEYS]: Object.keys(copilotConfig[\"body\"] ?? {}) }\n        : {}),\n      ...(body ? { ...body } : {}),\n    }),\n    signal,\n  });\n\n  return response;\n}\n\nexport interface DecodedChatCompletionResponse extends Response {\n  events: ReadableStream<ChatCompletionEvent> | null;\n}\n\nexport async function fetchAndDecodeChatCompletion(\n  params: FetchChatCompletionParams,\n): Promise<DecodedChatCompletionResponse> {\n  const response = await fetchChatCompletion(params);\n  if (!response.ok || !response.body) {\n    return { ...response, events: null };\n  }\n  const events = await decodeChatCompletion(parseChatCompletion(response.body));\n  return { ...response, events };\n}\n\nexport interface DecodedChatCompletionResponseAsText extends Response {\n  events: ReadableStream<string> | null;\n}\n\nexport async function fetchAndDecodeChatCompletionAsText(\n  params: FetchChatCompletionParams,\n): Promise<DecodedChatCompletionResponseAsText> {\n  const response = await fetchChatCompletion(params);\n  if (!response.ok || !response.body) {\n    return { ...response, events: null };\n  }\n  const events = await decodeChatCompletionAsText(\n    decodeChatCompletion(parseChatCompletion(response.body)),\n  );\n  return { ...response, events };\n}\n"],"mappings":"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","names":["import_shared"]}