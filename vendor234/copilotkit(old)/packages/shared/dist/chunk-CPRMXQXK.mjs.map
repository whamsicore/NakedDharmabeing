{"version":3,"sources":["../src/utils/decode-chat-completion.ts"],"sourcesContent":["import { ChatCompletionChunk } from \"./parse-chat-completion\";\n\nexport interface ChatCompletionContentEvent {\n  type: \"content\";\n  content: string;\n}\n\nexport interface ChatCompletionPartialEvent {\n  type: \"partial\";\n  name: string;\n  arguments: string;\n}\n\nexport interface ChatCompletionFunctionEvent {\n  type: \"function\";\n  name: string;\n  arguments: any;\n  scope: \"client\" | \"server\";\n}\n\nexport interface ChatCompletionResultEvent {\n  type: \"result\";\n  content: string;\n  name: string;\n}\n\nexport type ChatCompletionEvent =\n  | ChatCompletionContentEvent\n  | ChatCompletionPartialEvent\n  | ChatCompletionFunctionEvent\n  | ChatCompletionResultEvent;\n\nexport function decodeChatCompletion(\n  stream: ReadableStream<ChatCompletionChunk>,\n): ReadableStream<ChatCompletionEvent> {\n  const reader = stream.getReader();\n\n  let mode: \"function\" | \"message\" | null = null;\n  let functionCallName: string = \"\";\n  let functionCallArguments: string = \"\";\n  let functionCallScope: \"client\" | \"server\" = \"client\";\n\n  async function cleanup(controller?: ReadableStreamDefaultController<any>) {\n    if (controller) {\n      try {\n        controller.close();\n      } catch (_) {}\n    }\n    if (reader) {\n      try {\n        await reader.cancel();\n      } catch (_) {}\n    }\n  }\n\n  return new ReadableStream<ChatCompletionEvent>({\n    async pull(controller) {\n      const flushFunctionCall = (): boolean => {\n        let args: any = null;\n        try {\n          args = JSON.parse(functionCallArguments);\n        } catch (error) {\n          cleanup(controller);\n          controller.error(error);\n          return false;\n        }\n        controller.enqueue({\n          type: \"function\",\n          name: functionCallName,\n          arguments: args,\n          scope: functionCallScope,\n        });\n\n        mode = null;\n        functionCallName = \"\";\n        functionCallArguments = \"\";\n        return true;\n      };\n\n      while (true) {\n        try {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            if (mode === \"function\") {\n              flushFunctionCall();\n            }\n            await cleanup(controller);\n            return;\n          }\n\n          // TODO what can we get here now, since we can also get results back\n\n          // In case we are in a function call but the next message is\n          // - not a function call\n          // - another function call (when name is present)\n          // => flush it.\n          if (\n            mode === \"function\" &&\n            (!value.choices[0].delta.tool_calls?.[0]?.function ||\n              value.choices[0].delta.tool_calls?.[0]?.function.name)\n          ) {\n            if (!flushFunctionCall()) {\n              return;\n            }\n          }\n\n          mode = value.choices[0].delta.tool_calls?.[0]?.function ? \"function\" : \"message\";\n\n          // if we get a message, emit the content and continue;\n          if (mode === \"message\") {\n            // if we got a result message, send a result event\n            if (value.choices[0].delta.role === \"function\") {\n              controller.enqueue({\n                type: \"result\",\n                content: value.choices[0].delta.content!,\n                name: value.choices[0].delta.name!,\n              });\n            }\n            // otherwise, send a content event\n            else if (value.choices[0].delta.content) {\n              controller.enqueue({\n                type: \"content\",\n                content: value.choices[0].delta.content,\n              });\n            }\n            continue;\n          }\n          // if we get a function call, buffer the name and arguments, then emit a partial event.\n          else if (mode === \"function\") {\n            if (value.choices[0].delta.tool_calls![0].function.name) {\n              functionCallName = value.choices[0].delta.tool_calls![0].function.name!;\n            }\n            if (value.choices[0].delta.tool_calls![0].function.arguments) {\n              functionCallArguments += value.choices[0].delta.tool_calls![0].function.arguments!;\n            }\n            if (value.choices[0].delta.tool_calls![0].function.scope) {\n              functionCallScope = value.choices[0].delta.tool_calls![0].function.scope!;\n            }\n            controller.enqueue({\n              type: \"partial\",\n              name: functionCallName,\n              arguments: functionCallArguments,\n            });\n            continue;\n          }\n        } catch (error) {\n          controller.error(error);\n          await cleanup(controller);\n          return;\n        }\n      }\n    },\n    cancel() {\n      reader.cancel();\n    },\n  });\n}\n"],"mappings":"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","names":[]}