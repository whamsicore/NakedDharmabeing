{"version":3,"sources":["../src/types/action.ts"],"sourcesContent":["type TypeMap = {\n  string: string;\n  number: number;\n  boolean: boolean;\n  object: object;\n  \"string[]\": string[];\n  \"number[]\": number[];\n  \"boolean[]\": boolean[];\n  \"object[]\": object[];\n};\n\ntype BaseParameter = {\n  name: string;\n  type?: Exclude<keyof TypeMap, \"string\" | \"object\" | \"object[]\">; // Exclude object types for BaseParameter\n  description?: string;\n  required?: boolean;\n};\n\ntype StringParameter = {\n  name: string;\n  type: \"string\";\n  description?: string;\n  required?: boolean;\n  enum?: string[];\n};\n\ntype ObjectParameter = {\n  name: string;\n  type: \"object\" | \"object[]\";\n  description?: string;\n  required?: boolean;\n  attributes?: Parameter[]; // Optional for defining nested object structures\n};\n\ntype Parameter = BaseParameter | StringParameter | ObjectParameter;\n\ntype MappedParameterTypes<T extends Parameter[]> = {\n  // Check if enum is defined\n  [P in T[number] as P[\"name\"]]: P extends { enum: Array<infer E> }\n    ? // Ensure the inferred type E is string to match enum usage\n      E extends string\n      ? // Check if the parameter is marked as not required\n        P[\"required\"] extends false\n        ? // Make the type union with undefined\n          E | undefined\n        : // Use the inferred  type directly\n          E\n      : // If E is not string, this case should never happen\n        never\n    : // Handle object types with attributes\n    P extends { type: \"object\" | \"object[]\"; attributes: infer Attributes }\n    ? Attributes extends Parameter[]\n      ? // Recursively process nested attributes\n        MappedParameterTypes<Attributes>\n      : never\n    : // For types without enum and not object with attributes\n    // Check if the parameter is marked as not required\n    P[\"required\"] extends false\n    ? // Make the type union with undefined\n      TypeMap[P[\"type\"] extends keyof TypeMap ? P[\"type\"] : \"string\"] | undefined\n    : // Directly use TypeMap for type resolution\n      TypeMap[P[\"type\"] extends keyof TypeMap ? P[\"type\"] : \"string\"];\n};\n\ntype Action<T extends Parameter[] | [] = []> = {\n  name: string;\n  description?: string;\n  parameters?: T;\n  handler: T extends [] ? () => void : (args: MappedParameterTypes<T>) => void;\n};\n\n// Prettier chokes on the `const` in the function signature\n// as a workaround, comment out the const keyword when working with this code and\n// uncomment when done\n\n// prettier-ignore\nexport function useCopilotAction<const T extends Parameter[] | [] = []>(action: Action<T>): void {\n  // Function implementation...\n}\n\n// https://community.openai.com/t/function-call-complex-arrays-as-parameters/295648/3\n"],"mappings":";AA4EO,SAAS,iBAAwD,QAAyB;AAEjG;","names":[]}