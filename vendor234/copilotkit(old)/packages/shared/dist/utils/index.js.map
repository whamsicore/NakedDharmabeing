{"version":3,"sources":["../../src/utils/index.ts","../../src/utils/utils.ts","../../src/utils/parse-chat-completion.ts","../../src/utils/decode-chat-completion.ts","../../src/utils/decode-chat-completion-as-text.ts","../../src/utils/annotated-function.ts"],"sourcesContent":["export * from \"./utils\";\nexport * from \"./parse-chat-completion\";\nexport * from \"./decode-chat-completion\";\nexport * from \"./decode-chat-completion-as-text\";\nexport * from \"./annotated-function\";\n","import { AssistantMessage, FunctionCall, JSONValue } from \"../types/openai-assistant\";\n\nexport function encodeResult(result: string): string {\n  if (result === undefined) {\n    return \"\";\n  } else if (typeof result === \"string\") {\n    return result;\n  } else {\n    return JSON.stringify(result);\n  }\n}\n\nexport interface StreamPart<CODE extends string, NAME extends string, TYPE> {\n  code: CODE;\n  name: NAME;\n  parse: (value: JSONValue) => { type: NAME; value: TYPE };\n}\n\nconst textStreamPart: StreamPart<\"0\", \"text\", string> = {\n  code: \"0\",\n  name: \"text\",\n  parse: (value: JSONValue) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: \"text\", value };\n  },\n};\n\n/**\n * This is a utility function that helps in parsing the stream parts.\n * It takes a JSONValue as input and returns an object with type and value.\n * The type is a string that represents the type of the stream part.\n * The value is the actual value of the stream part.\n * If the input value is not a string, it throws an error.\n */\nconst functionCallStreamPart: StreamPart<\"1\", \"function_call\", { function_call: FunctionCall }> = {\n  code: \"1\",\n  name: \"function_call\",\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== \"object\" ||\n      !(\"function_call\" in value) ||\n      typeof value.function_call !== \"object\" ||\n      value.function_call == null ||\n      !(\"name\" in value.function_call) ||\n      !(\"arguments\" in value.function_call) ||\n      typeof value.function_call.name !== \"string\" ||\n      typeof value.function_call.arguments !== \"string\"\n    ) {\n      throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n    }\n\n    return {\n      type: \"function_call\",\n      value: value as unknown as { function_call: FunctionCall },\n    };\n  },\n};\n\nconst dataStreamPart: StreamPart<\"2\", \"data\", Array<JSONValue>> = {\n  code: \"2\",\n  name: \"data\",\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n\n    return { type: \"data\", value };\n  },\n};\n\nconst errorStreamPart: StreamPart<\"3\", \"error\", string> = {\n  code: \"3\",\n  name: \"error\",\n  parse: (value: JSONValue) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: \"error\", value };\n  },\n};\n\nconst assistantMessage: StreamPart<\"4\", \"assistant_message\", AssistantMessage> = {\n  code: \"4\",\n  name: \"assistant_message\",\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== \"object\" ||\n      !(\"id\" in value) ||\n      !(\"role\" in value) ||\n      !(\"content\" in value) ||\n      typeof value.id !== \"string\" ||\n      typeof value.role !== \"string\" ||\n      value.role !== \"assistant\" ||\n      !Array.isArray(value.content) ||\n      !value.content.every(\n        (item) =>\n          item != null &&\n          typeof item === \"object\" &&\n          \"type\" in item &&\n          item.type === \"text\" &&\n          \"text\" in item &&\n          item.text != null &&\n          typeof item.text === \"object\" &&\n          \"value\" in item.text &&\n          typeof item.text.value === \"string\",\n      )\n    ) {\n      throw new Error(\n        '\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.',\n      );\n    }\n\n    return {\n      type: \"assistant_message\",\n      value: value as AssistantMessage,\n    };\n  },\n};\n\nconst assistantControlData: StreamPart<\n  \"5\",\n  \"assistant_control_data\",\n  {\n    threadId: string;\n    messageId: string;\n  }\n> = {\n  code: \"5\",\n  name: \"assistant_control_data\",\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== \"object\" ||\n      !(\"threadId\" in value) ||\n      !(\"messageId\" in value) ||\n      typeof value.threadId !== \"string\" ||\n      typeof value.messageId !== \"string\"\n    ) {\n      throw new Error(\n        '\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.',\n      );\n    }\n\n    return {\n      type: \"assistant_control_data\",\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId,\n      },\n    };\n  },\n};\n\nconst streamParts = [\n  textStreamPart,\n  functionCallStreamPart,\n  dataStreamPart,\n  errorStreamPart,\n  assistantMessage,\n  assistantControlData,\n] as const;\n\n// union type of all stream parts\ntype StreamParts =\n  | typeof textStreamPart\n  | typeof functionCallStreamPart\n  | typeof dataStreamPart\n  | typeof errorStreamPart\n  | typeof assistantMessage\n  | typeof assistantControlData;\n\n/**\n * Maps the type of a stream part to its value type.\n */\ntype StreamPartValueType = {\n  [P in StreamParts as P[\"name\"]]: ReturnType<P[\"parse\"]>[\"value\"];\n};\n\nexport type StreamPartType =\n  | ReturnType<typeof textStreamPart.parse>\n  | ReturnType<typeof functionCallStreamPart.parse>\n  | ReturnType<typeof dataStreamPart.parse>\n  | ReturnType<typeof errorStreamPart.parse>\n  | ReturnType<typeof assistantMessage.parse>\n  | ReturnType<typeof assistantControlData.parse>;\n\nexport const streamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [functionCallStreamPart.code]: functionCallStreamPart,\n  [dataStreamPart.code]: dataStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessage.code]: assistantMessage,\n  [assistantControlData.code]: assistantControlData,\n} as const;\n\n/**\n * The map of prefixes for data in the stream\n *\n * - 0: Text from the LLM response\n * - 1: (OpenAI) function_call responses\n * - 2: custom JSON added by the user using `Data`\n *\n * Example:\n * ```\n * 0:Vercel\n * 0:'s\n * 0: AI\n * 0: AI\n * 0: SDK\n * 0: is great\n * 0:!\n * 2: { \"someJson\": \"value\" }\n * 1: {\"function_call\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}\n *```\n */\nexport const StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [functionCallStreamPart.name]: functionCallStreamPart.code,\n  [dataStreamPart.name]: dataStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessage.name]: assistantMessage.code,\n  [assistantControlData.name]: assistantControlData.code,\n} as const;\n\nexport const validCodes = streamParts.map((part) => part.code);\n\n/**\n * Parses a stream part from a string.\n *\n * @param line The string to parse.\n * @returns The parsed stream part.\n * @throws An error if the string cannot be parsed.\n */\nexport const parseStreamPart = (line: string): StreamPartType => {\n  const firstSeparatorIndex = line.indexOf(\":\");\n\n  if (firstSeparatorIndex === -1) {\n    throw new Error(\"Failed to parse stream string. No separator found.\");\n  }\n\n  const prefix = line.slice(0, firstSeparatorIndex);\n\n  if (!validCodes.includes(prefix as keyof typeof streamPartsByCode)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n\n  const code = prefix as keyof typeof streamPartsByCode;\n\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue: JSONValue = JSON.parse(textValue);\n\n  return streamPartsByCode[code].parse(jsonValue);\n};\n\n/**\n * Prepends a string with a prefix from the `StreamChunkPrefixes`, JSON-ifies it,\n * and appends a new line.\n *\n * It ensures type-safety for the part type and value.\n */\nexport function formatStreamPart<T extends keyof StreamPartValueType>(\n  type: T,\n  value: StreamPartValueType[T],\n): StreamString {\n  const streamPart = streamParts.find((part) => part.name === type);\n\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n\n  return `${streamPart.code}:${JSON.stringify(value)}\\n`;\n}\n\nexport const isStreamStringEqualToType = (\n  type: keyof typeof StreamStringPrefixes,\n  value: string,\n): value is StreamString =>\n  value.startsWith(`${StreamStringPrefixes[type]}:`) && value.endsWith(\"\\n\");\n\nexport type StreamString =\n  `${typeof StreamStringPrefixes[keyof typeof StreamStringPrefixes]}:${string}\\n`;\n\n/**\n * A header sent to the client so it knows how to handle parsing the stream (as a deprecated text response or using the new prefixed protocol)\n */\nexport const COMPLEX_HEADER = \"X-Experimental-Stream-Data\";\n","import { Role } from \"../types/openai-assistant\";\n\nexport interface ChatCompletionChunk {\n  choices: {\n    delta: {\n      role: Role;\n      content?: string | null;\n\n      // TODO:\n      // Temporarily add name to the OpenAI protocol until we\n      // have our own protocol.\n      // When name is set, we return the result of a server-side\n      // function call.\n      name?: string;\n\n      function_call?: {\n        name?: string;\n        arguments?: string;\n      };\n      tool_calls?: {\n        index: number;\n        id?: string;\n        function: {\n          arguments?: string;\n\n          name?: string;\n          // TODO:\n          // Temporarily add scope to the OpenAI protocol until we\n          // have our own protocol.\n          // When scope is \"server\", the client will not attempt to\n          // execute the function.\n          scope?: \"client\" | \"server\";\n        };\n      }[];\n    };\n  }[];\n}\n\n// TODO:\n// it's possible that unicode characters could be split across chunks\n// make sure to properly handle that\nexport function parseChatCompletion(\n  stream: ReadableStream<Uint8Array>,\n): ReadableStream<ChatCompletionChunk> {\n  const reader = stream.getReader();\n  let buffer = new Uint8Array();\n\n  async function cleanup(controller?: ReadableStreamDefaultController<any>) {\n    if (controller) {\n      try {\n        controller.close();\n      } catch (_) {}\n    }\n    if (reader) {\n      try {\n        await reader.cancel();\n      } catch (_) {}\n    }\n  }\n\n  return new ReadableStream<ChatCompletionChunk>({\n    async pull(controller) {\n      while (true) {\n        try {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            await cleanup(controller);\n            return;\n          }\n\n          const newBuffer = new Uint8Array(buffer.length + value.length);\n          newBuffer.set(buffer);\n          newBuffer.set(value, buffer.length);\n          buffer = newBuffer;\n\n          const valueString = new TextDecoder(\"utf-8\").decode(buffer);\n          const lines = valueString.split(\"\\n\").filter((line) => line.trim() !== \"\");\n\n          // If the last line isn't complete, keep it in the buffer for next time\n          buffer = !valueString.endsWith(\"\\n\")\n            ? new TextEncoder().encode(lines.pop() || \"\")\n            : new Uint8Array();\n\n          for (const line of lines) {\n            const cleanedLine = line.replace(/^data: /, \"\");\n\n            if (cleanedLine === \"[DONE]\") {\n              await cleanup(controller);\n              return;\n            }\n\n            const json = JSON.parse(cleanedLine);\n            controller.enqueue(json);\n          }\n        } catch (error) {\n          controller.error(error);\n          await cleanup(controller);\n          return;\n        }\n      }\n    },\n    cancel() {\n      reader.cancel();\n    },\n  });\n}\n","import { ChatCompletionChunk } from \"./parse-chat-completion\";\n\nexport interface ChatCompletionContentEvent {\n  type: \"content\";\n  content: string;\n}\n\nexport interface ChatCompletionPartialEvent {\n  type: \"partial\";\n  name: string;\n  arguments: string;\n}\n\nexport interface ChatCompletionFunctionEvent {\n  type: \"function\";\n  name: string;\n  arguments: any;\n  scope: \"client\" | \"server\";\n}\n\nexport interface ChatCompletionResultEvent {\n  type: \"result\";\n  content: string;\n  name: string;\n}\n\nexport type ChatCompletionEvent =\n  | ChatCompletionContentEvent\n  | ChatCompletionPartialEvent\n  | ChatCompletionFunctionEvent\n  | ChatCompletionResultEvent;\n\nexport function decodeChatCompletion(\n  stream: ReadableStream<ChatCompletionChunk>,\n): ReadableStream<ChatCompletionEvent> {\n  const reader = stream.getReader();\n\n  let mode: \"function\" | \"message\" | null = null;\n  let functionCallName: string = \"\";\n  let functionCallArguments: string = \"\";\n  let functionCallScope: \"client\" | \"server\" = \"client\";\n\n  async function cleanup(controller?: ReadableStreamDefaultController<any>) {\n    if (controller) {\n      try {\n        controller.close();\n      } catch (_) {}\n    }\n    if (reader) {\n      try {\n        await reader.cancel();\n      } catch (_) {}\n    }\n  }\n\n  return new ReadableStream<ChatCompletionEvent>({\n    async pull(controller) {\n      const flushFunctionCall = (): boolean => {\n        let args: any = null;\n        try {\n          args = JSON.parse(functionCallArguments);\n        } catch (error) {\n          cleanup(controller);\n          controller.error(error);\n          return false;\n        }\n        controller.enqueue({\n          type: \"function\",\n          name: functionCallName,\n          arguments: args,\n          scope: functionCallScope,\n        });\n\n        mode = null;\n        functionCallName = \"\";\n        functionCallArguments = \"\";\n        return true;\n      };\n\n      while (true) {\n        try {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            if (mode === \"function\") {\n              flushFunctionCall();\n            }\n            await cleanup(controller);\n            return;\n          }\n\n          // TODO what can we get here now, since we can also get results back\n\n          // In case we are in a function call but the next message is\n          // - not a function call\n          // - another function call (when name is present)\n          // => flush it.\n          if (\n            mode === \"function\" &&\n            (!value.choices[0].delta.tool_calls?.[0]?.function ||\n              value.choices[0].delta.tool_calls?.[0]?.function.name)\n          ) {\n            if (!flushFunctionCall()) {\n              return;\n            }\n          }\n\n          mode = value.choices[0].delta.tool_calls?.[0]?.function ? \"function\" : \"message\";\n\n          // if we get a message, emit the content and continue;\n          if (mode === \"message\") {\n            // if we got a result message, send a result event\n            if (value.choices[0].delta.role === \"function\") {\n              controller.enqueue({\n                type: \"result\",\n                content: value.choices[0].delta.content!,\n                name: value.choices[0].delta.name!,\n              });\n            }\n            // otherwise, send a content event\n            else if (value.choices[0].delta.content) {\n              controller.enqueue({\n                type: \"content\",\n                content: value.choices[0].delta.content,\n              });\n            }\n            continue;\n          }\n          // if we get a function call, buffer the name and arguments, then emit a partial event.\n          else if (mode === \"function\") {\n            if (value.choices[0].delta.tool_calls![0].function.name) {\n              functionCallName = value.choices[0].delta.tool_calls![0].function.name!;\n            }\n            if (value.choices[0].delta.tool_calls![0].function.arguments) {\n              functionCallArguments += value.choices[0].delta.tool_calls![0].function.arguments!;\n            }\n            if (value.choices[0].delta.tool_calls![0].function.scope) {\n              functionCallScope = value.choices[0].delta.tool_calls![0].function.scope!;\n            }\n            controller.enqueue({\n              type: \"partial\",\n              name: functionCallName,\n              arguments: functionCallArguments,\n            });\n            continue;\n          }\n        } catch (error) {\n          controller.error(error);\n          await cleanup(controller);\n          return;\n        }\n      }\n    },\n    cancel() {\n      reader.cancel();\n    },\n  });\n}\n","import { ChatCompletionEvent } from \"./decode-chat-completion\";\n\nexport function decodeChatCompletionAsText(\n  stream: ReadableStream<ChatCompletionEvent>,\n): ReadableStream<string> {\n  const reader = stream.getReader();\n\n  return new ReadableStream<string>({\n    async pull(controller) {\n      while (true) {\n        try {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            controller.close();\n            return;\n          }\n\n          if (value.type === \"content\") {\n            controller.enqueue(value.content);\n            continue;\n          }\n        } catch (error) {\n          controller.error(error);\n          return;\n        }\n      }\n    },\n    cancel() {\n      reader.cancel();\n    },\n  });\n}\n","import { AnnotatedFunction, FunctionDefinition, ToolDefinition } from \"../types\";\n\nexport function annotatedFunctionToChatCompletionFunction(\n  annotatedFunction: AnnotatedFunction<any[]>,\n): ToolDefinition {\n  // Create the parameters object based on the argumentAnnotations\n  let parameters: { [key: string]: any } = {};\n  for (let arg of annotatedFunction.argumentAnnotations) {\n    // isolate the args we should forward inline\n    let { name, required, ...forwardedArgs } = arg;\n    parameters[arg.name] = forwardedArgs;\n  }\n\n  let requiredParameterNames: string[] = [];\n  for (let arg of annotatedFunction.argumentAnnotations) {\n    if (arg.required) {\n      requiredParameterNames.push(arg.name);\n    }\n  }\n\n  // Create the ChatCompletionFunctions object\n  let chatCompletionFunction: ToolDefinition = {\n    type: \"function\",\n    function: {\n      name: annotatedFunction.name,\n      description: annotatedFunction.description,\n      parameters: {\n        type: \"object\",\n        properties: parameters,\n        required: requiredParameterNames,\n      },\n    },\n  };\n\n  return chatCompletionFunction;\n}\n"],"mappings":"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","names":[]}