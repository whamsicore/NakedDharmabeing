{"version":3,"sources":["../../src/types/action.ts","../../src/types/test.ts"],"sourcesContent":["type TypeMap = {\n  string: string;\n  number: number;\n  boolean: boolean;\n  object: object;\n  \"string[]\": string[];\n  \"number[]\": number[];\n  \"boolean[]\": boolean[];\n  \"object[]\": object[];\n};\n\ntype BaseParameter = {\n  name: string;\n  type?: Exclude<keyof TypeMap, \"string\" | \"object\" | \"object[]\">; // Exclude object types for BaseParameter\n  description?: string;\n  required?: boolean;\n};\n\ntype StringParameter = {\n  name: string;\n  type: \"string\";\n  description?: string;\n  required?: boolean;\n  enum?: string[];\n};\n\ntype ObjectParameter = {\n  name: string;\n  type: \"object\" | \"object[]\";\n  description?: string;\n  required?: boolean;\n  attributes?: Parameter[]; // Optional for defining nested object structures\n};\n\ntype Parameter = BaseParameter | StringParameter | ObjectParameter;\n\ntype MappedParameterTypes<T extends Parameter[]> = {\n  // Check if enum is defined\n  [P in T[number] as P[\"name\"]]: P extends { enum: Array<infer E> }\n    ? // Ensure the inferred type E is string to match enum usage\n      E extends string\n      ? // Check if the parameter is marked as not required\n        P[\"required\"] extends false\n        ? // Make the type union with undefined\n          E | undefined\n        : // Use the inferred  type directly\n          E\n      : // If E is not string, this case should never happen\n        never\n    : // Handle object types with attributes\n    P extends { type: \"object\" | \"object[]\"; attributes: infer Attributes }\n    ? Attributes extends Parameter[]\n      ? // Recursively process nested attributes\n        MappedParameterTypes<Attributes>\n      : never\n    : // For types without enum and not object with attributes\n    // Check if the parameter is marked as not required\n    P[\"required\"] extends false\n    ? // Make the type union with undefined\n      TypeMap[P[\"type\"] extends keyof TypeMap ? P[\"type\"] : \"string\"] | undefined\n    : // Directly use TypeMap for type resolution\n      TypeMap[P[\"type\"] extends keyof TypeMap ? P[\"type\"] : \"string\"];\n};\n\ntype Action<T extends Parameter[] | [] = []> = {\n  name: string;\n  description?: string;\n  parameters?: T;\n  handler: T extends [] ? () => void : (args: MappedParameterTypes<T>) => void;\n};\n\n// Prettier chokes on the `const` in the function signature\n// as a workaround, comment out the const keyword when working with this code and\n// uncomment when done\n\n// prettier-ignore\nexport function useCopilotAction<const T extends Parameter[] | [] = []>(action: Action<T>): void {\n  // Function implementation...\n}\n\n// https://community.openai.com/t/function-call-complex-arrays-as-parameters/295648/3\n","import { useCopilotAction } from \"./action\";\n\n// Usage Example:\nuseCopilotAction({\n  name: \"myAction\",\n  parameters: [\n    { name: \"arg1\", type: \"string\", enum: [\"option1\", \"option2\", \"option3\"], required: false },\n    { name: \"arg2\", type: \"number\" },\n    {\n      name: \"arg3\",\n      type: \"object\",\n      attributes: [\n        { name: \"nestedArg1\", type: \"boolean\" },\n        { name: \"xyz\", required: false },\n      ],\n    },\n    { name: \"arg4\", type: \"number[]\" },\n  ] as const,\n  handler: ({ arg1, arg2, arg3, arg4 }) => {\n    const x = arg3.nestedArg1;\n    const z = arg3.xyz;\n    console.log(arg1, arg2, arg3);\n  },\n});\n\nuseCopilotAction({\n  name: \"myAction\",\n  handler: () => {\n    console.log(\"No parameters provided.\");\n  },\n});\n"],"mappings":";;;AA4EO,SAAS,iBAAwD,QAAyB;AAEjG;;;AC3EA,iBAAiB;AAAA,EACf,MAAM;AAAA,EACN,YAAY;AAAA,IACV,EAAE,MAAM,QAAQ,MAAM,UAAU,MAAM,CAAC,WAAW,WAAW,SAAS,GAAG,UAAU,MAAM;AAAA,IACzF,EAAE,MAAM,QAAQ,MAAM,SAAS;AAAA,IAC/B;AAAA,MACE,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY;AAAA,QACV,EAAE,MAAM,cAAc,MAAM,UAAU;AAAA,QACtC,EAAE,MAAM,OAAO,UAAU,MAAM;AAAA,MACjC;AAAA,IACF;AAAA,IACA,EAAE,MAAM,QAAQ,MAAM,WAAW;AAAA,EACnC;AAAA,EACA,SAAS,CAAC,EAAE,MAAM,MAAM,MAAM,KAAK,MAAM;AACvC,UAAM,IAAI,KAAK;AACf,UAAM,IAAI,KAAK;AACf,YAAQ,IAAI,MAAM,MAAM,IAAI;AAAA,EAC9B;AACF,CAAC;AAED,iBAAiB;AAAA,EACf,MAAM;AAAA,EACN,SAAS,MAAM;AACb,YAAQ,IAAI,yBAAyB;AAAA,EACvC;AACF,CAAC;","names":[]}