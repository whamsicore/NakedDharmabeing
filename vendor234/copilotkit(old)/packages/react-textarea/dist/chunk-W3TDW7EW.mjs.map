{"version":3,"sources":["../src/components/hovering-toolbar/hovering-toolbar.tsx"],"sourcesContent":["import { useEffect, useRef, useState } from \"react\";\nimport { Editor, Location, Transforms } from \"slate\";\nimport { useSlate, useSlateSelection } from \"slate-react\";\nimport { HoveringInsertionPromptBox } from \"./text-insertion-prompt-box\";\nimport { Menu, Portal } from \"./hovering-toolbar-components\";\nimport { useHoveringEditorContext } from \"./hovering-editor-provider\";\nimport {\n  getFullEditorTextWithNewlines,\n  getTextAroundSelection,\n} from \"../../lib/get-text-around-cursor\";\nimport {\n  EditingEditorState,\n  InsertionEditorApiConfig,\n} from \"../../types/base/autosuggestions-bare-function\";\n\nexport interface HoveringToolbarProps {\n  apiConfig: InsertionEditorApiConfig;\n  contextCategories: string[];\n  hoverMenuClassname: string | undefined;\n}\n\nexport const HoveringToolbar = (props: HoveringToolbarProps) => {\n  const ref = useRef<HTMLDivElement>(null);\n  const editor = useSlate();\n  const selection = useSlateSelection();\n  const { isDisplayed, setIsDisplayed } = useHoveringEditorContext();\n\n  // only render on client\n  const [isClient, setIsClient] = useState(false);\n  useEffect(() => {\n    setIsClient(true);\n  }, []);\n\n  useEffect(() => {\n    const el = ref.current;\n    const { selection } = editor;\n\n    if (!el) {\n      return;\n    }\n\n    if (!selection) {\n      el.removeAttribute(\"style\");\n      return;\n    }\n\n    const domSelection = window.getSelection();\n    if (!domSelection) {\n      return;\n    }\n\n    const domRange = domSelection.getRangeAt(0);\n    const rect = domRange.getBoundingClientRect();\n\n    // We use window = (0,0,0,0) as a signal that the selection is not in the original copilot-textarea,\n    // but inside the hovering window.\n    //\n    // in such case, we simply do nothing.\n    if (rect.top === 0 && rect.left === 0 && rect.width === 0 && rect.height === 0) {\n      return;\n    }\n\n    const minGapFromEdge = 60;\n    const verticalOffsetFromCorner = 35;\n    const horizontalOffsetFromCorner = 15;\n    let top = rect.top + window.scrollY - el.offsetHeight + verticalOffsetFromCorner;\n    // make sure top is in the viewport and not too close to the edge\n    if (top < minGapFromEdge) {\n      top = rect.bottom + window.scrollY + minGapFromEdge;\n    } else if (top + el.offsetHeight > window.innerHeight - minGapFromEdge) {\n      top = rect.top + window.scrollY - el.offsetHeight - minGapFromEdge;\n    }\n\n    let left =\n      rect.left + window.scrollX - el.offsetWidth / 2 + rect.width / 2 + horizontalOffsetFromCorner;\n    // make sure left is in the viewport and not too close to the edge\n    if (left < minGapFromEdge) {\n      left = minGapFromEdge;\n    } else if (left + el.offsetWidth > window.innerWidth - minGapFromEdge) {\n      left = window.innerWidth - el.offsetWidth - minGapFromEdge;\n    }\n\n    el.style.opacity = \"1\";\n    el.style.top = `${top}px`;\n    el.style.left = `${left}px`;\n  });\n\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (ref.current && !ref.current.contains(event.target as Node)) {\n        setIsDisplayed(false);\n      }\n    };\n\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => {\n      document.removeEventListener(\"mousedown\", handleClickOutside);\n    };\n  }, [ref, setIsDisplayed]);\n\n  if (!isClient) {\n    return null;\n  }\n\n  return (\n    <Portal>\n      <Menu\n        ref={ref}\n        className={\n          props.hoverMenuClassname ||\n          \"p-2 absolute z-10 top-[-10000px] left-[-10000px] mt-[-6px] opacity-0 transition-opacity duration-700\"\n        }\n      >\n        {isDisplayed && selection && (\n          <HoveringInsertionPromptBox\n            editorState={editorState(editor, selection)}\n            apiConfig={props.apiConfig}\n            closeWindow={() => {\n              setIsDisplayed(false);\n            }}\n            performInsertion={(insertedText) => {\n              console.log(\"inserted text\", insertedText);\n              // replace the selection with the inserted text\n              Transforms.delete(editor, { at: selection });\n              Transforms.insertText(editor, insertedText, {\n                at: selection,\n              });\n              setIsDisplayed(false);\n            }}\n            contextCategories={props.contextCategories}\n          />\n        )}\n      </Menu>\n    </Portal>\n  );\n};\n\nfunction editorState(editor: Editor, selection: Location): EditingEditorState {\n  const textAroundCursor = getTextAroundSelection(editor);\n  if (textAroundCursor) {\n    return textAroundCursor;\n  }\n\n  return {\n    textBeforeCursor: getFullEditorTextWithNewlines(editor),\n    textAfterCursor: \"\",\n    selectedText: \"\",\n  };\n}\n"],"mappings":"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","names":["selection"]}