{"version":3,"sources":["../../../src/hooks/base-copilot-textarea-implementation/use-copilot-textarea-editor.tsx","../../../src/lib/slatejs-edits/with-partial-history.ts"],"sourcesContent":["import { useMemo } from \"react\";\nimport { createEditor, Element } from \"slate\";\nimport { withReact } from \"slate-react\";\nimport {\n  defaultShouldSave,\n  ShouldSaveToHistory,\n  withPartialHistory,\n} from \"../../lib/slatejs-edits/with-partial-history\";\nimport { CustomEditor } from \"../../types/base/custom-editor\";\n\nconst shouldSave: ShouldSaveToHistory = (op, prev) => {\n  const excludedNodeType = \"suggestion\";\n  // Check if the operation involves the suggestion inline node type\n  if (\n    op.type === \"insert_node\" &&\n    Element.isElement(op.node) &&\n    op.node.type === excludedNodeType\n  ) {\n    return false;\n  }\n\n  if (\n    op.type === \"remove_node\" &&\n    Element.isElement(op.node) &&\n    op.node.type === excludedNodeType\n  ) {\n    return false;\n  }\n\n  if (\n    op.type === \"set_node\" &&\n    \"type\" in op.newProperties &&\n    op.newProperties.type === excludedNodeType\n  ) {\n    return false;\n  }\n\n  if (op.type == \"set_node\" && \"type\" in op.properties && op.properties.type === excludedNodeType) {\n    return false;\n  }\n\n  if (\n    op.type === \"merge_node\" &&\n    \"type\" in op.properties &&\n    op.properties.type === excludedNodeType\n  ) {\n    return false;\n  }\n\n  if (\n    op.type === \"split_node\" &&\n    \"type\" in op.properties &&\n    op.properties.type === excludedNodeType\n  ) {\n    return false;\n  }\n\n  // Otherwise, save the operation to history\n  return defaultShouldSave(op, prev);\n};\n\nexport function useCopilotTextareaEditor(): CustomEditor {\n  const editor = useMemo(() => {\n    const editor = withPartialHistory(withReact(createEditor()), shouldSave);\n\n    const { isVoid } = editor;\n    editor.isVoid = (element) => {\n      switch (element.type) {\n        case \"suggestion\":\n          return true;\n        default:\n          return isVoid(element);\n      }\n    };\n\n    const { markableVoid } = editor;\n    editor.markableVoid = (element) => {\n      switch (element.type) {\n        case \"suggestion\":\n          return true;\n        default:\n          return markableVoid(element);\n      }\n    };\n\n    const { isInline } = editor;\n    editor.isInline = (element) => {\n      switch (element.type) {\n        case \"suggestion\":\n          return element.inline;\n        default:\n          return isInline(element);\n      }\n    };\n\n    return editor;\n  }, []);\n\n  return editor;\n}\n","import { Editor, Operation, Path, Range, Transforms } from \"slate\";\nimport { HistoryEditor } from \"slate-history\";\n\n// Copy-pasted from `https://github.com/ianstormtaylor/slate/blob/main/packages/slate-history/src/with-history.ts`\n// With one exception: the `shouldSave` function is passed in as an argument to `withPartialHistory` instead of being hardcoded\nexport type ShouldSaveToHistory = (op: Operation, prev: Operation | undefined) => boolean;\n\nexport const withPartialHistory = <T extends Editor>(\n  editor: T,\n  shouldSave: ShouldSaveToHistory,\n) => {\n  const e = editor as T & HistoryEditor;\n  const { apply } = e;\n  e.history = { undos: [], redos: [] };\n\n  e.redo = () => {\n    const { history } = e;\n    const { redos } = history;\n\n    if (redos.length > 0) {\n      const batch = redos[redos.length - 1];\n\n      if (batch.selectionBefore) {\n        Transforms.setSelection(e, batch.selectionBefore);\n      }\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          for (const op of batch.operations) {\n            e.apply(op);\n          }\n        });\n      });\n\n      history.redos.pop();\n      e.writeHistory(\"undos\", batch);\n    }\n  };\n\n  e.undo = () => {\n    const { history } = e;\n    const { undos } = history;\n\n    if (undos.length > 0) {\n      const batch = undos[undos.length - 1];\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          const inverseOps = batch.operations.map(Operation.inverse).reverse();\n\n          for (const op of inverseOps) {\n            e.apply(op);\n          }\n          if (batch.selectionBefore) {\n            Transforms.setSelection(e, batch.selectionBefore);\n          }\n        });\n      });\n\n      e.writeHistory(\"redos\", batch);\n      history.undos.pop();\n    }\n  };\n\n  e.apply = (op: Operation) => {\n    const { operations, history } = e;\n    const { undos } = history;\n    const lastBatch = undos[undos.length - 1];\n    const lastOp = lastBatch && lastBatch.operations[lastBatch.operations.length - 1];\n    let save = HistoryEditor.isSaving(e);\n    let merge = HistoryEditor.isMerging(e);\n\n    if (save == null) {\n      save = shouldSave(op, lastOp);\n    }\n\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false;\n        } else if (operations.length !== 0) {\n          merge = true;\n        } else {\n          merge = shouldMerge(op, lastOp);\n        }\n      }\n\n      if (lastBatch && merge) {\n        lastBatch.operations.push(op);\n      } else {\n        const batch = {\n          operations: [op],\n          selectionBefore: e.selection,\n        };\n        e.writeHistory(\"undos\", batch);\n      }\n\n      while (undos.length > 100) {\n        undos.shift();\n      }\n\n      history.redos = [];\n    }\n\n    apply(op);\n  };\n\n  e.writeHistory = (stack: \"undos\" | \"redos\", batch: any) => {\n    e.history[stack].push(batch);\n  };\n\n  return e;\n};\n\n/**\n * Check whether to merge an operation into the previous operation.\n */\n\nconst shouldMerge = (op: Operation, prev: Operation | undefined): boolean => {\n  if (\n    prev &&\n    op.type === \"insert_text\" &&\n    prev.type === \"insert_text\" &&\n    op.offset === prev.offset + prev.text.length &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true;\n  }\n\n  if (\n    prev &&\n    op.type === \"remove_text\" &&\n    prev.type === \"remove_text\" &&\n    op.offset + op.text.length === prev.offset &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const defaultShouldSave = (op: Operation, prev: Operation | undefined): boolean => {\n  if (op.type === \"set_selection\") {\n    return false;\n  }\n\n  return true;\n};\n"],"mappings":"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","names":["import_slate","shouldSave","editor"]}