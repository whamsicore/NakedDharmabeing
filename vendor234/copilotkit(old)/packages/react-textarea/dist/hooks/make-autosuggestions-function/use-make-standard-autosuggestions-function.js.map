{"version":3,"sources":["../../../src/hooks/make-autosuggestions-function/use-make-standard-autosuggestions-function.tsx","../../../src/lib/retry.tsx"],"sourcesContent":["import { Message } from \"@copilotkit/shared\";\nimport { CopilotContext } from \"@copilotkit/react-core\";\nimport { useCallback, useContext } from \"react\";\nimport { AutosuggestionsBareFunction, MinimalChatGPTMessage } from \"../../types\";\nimport { retry } from \"../../lib/retry\";\nimport { InsertionEditorState } from \"../../types/base/autosuggestions-bare-function\";\nimport { SuggestionsApiConfig } from \"../../types/autosuggestions-config/suggestions-api-config\";\nimport { fetchAndDecodeChatCompletionAsText } from \"@copilotkit/react-core\";\n\n/**\n * Returns a memoized function that sends a request to the specified API endpoint to get an autosuggestion for the user's input.\n * The function takes in the text before and after the cursor, and an abort signal.\n * It sends a POST request to the API endpoint with the messages array containing the system message, few shot messages, and user messages.\n * The function returns the suggestion from the API response.\n *\n * @param textareaPurpose - The purpose of the textarea. This is included in the system message.\n * @param apiEndpoint - The API endpoint to send the autosuggestion request to.\n * @param makeSystemMessage - A function that takes in a context string and returns a system message to include in the autosuggestion request.\n * @param fewShotMessages - An array of few shot messages to include in the autosuggestion request.\n * @param contextCategories - The categories of context strings we want to include. By default, we include the (default) \"global\" context category.\n * @returns A memoized function that sends a request to the specified API endpoint to get an autosuggestion for the user's input.\n */\nexport function useMakeStandardAutosuggestionFunction(\n  textareaPurpose: string,\n  contextCategories: string[],\n  apiConfig: SuggestionsApiConfig,\n): AutosuggestionsBareFunction {\n  const { getContextString, copilotApiConfig } = useContext(CopilotContext);\n\n  return useCallback(\n    async (editorState: InsertionEditorState, abortSignal: AbortSignal) => {\n      const res = await retry(async () => {\n        const messages: MinimalChatGPTMessage[] = [\n          {\n            role: \"system\",\n            content: apiConfig.makeSystemPrompt(\n              textareaPurpose,\n              getContextString([], contextCategories),\n            ),\n          },\n          ...apiConfig.fewShotMessages,\n          {\n            role: \"user\",\n            name: \"TextAfterCursor\",\n            content: editorState.textAfterCursor,\n          },\n          {\n            role: \"user\",\n            name: \"TextBeforeCursor\",\n            content: editorState.textBeforeCursor,\n          },\n        ];\n\n        const response = await fetchAndDecodeChatCompletionAsText({\n          messages: messages as Message[],\n          ...apiConfig.forwardedParams,\n          copilotConfig: copilotApiConfig,\n          signal: abortSignal,\n        });\n\n        if (!response.events) {\n          throw new Error(\"Failed to fetch chat completion\");\n        }\n\n        const reader = response.events.getReader();\n\n        let result = \"\";\n        while (!abortSignal.aborted) {\n          const { done, value } = await reader.read();\n          if (done) {\n            break;\n          }\n          result += value;\n        }\n        return result;\n      });\n\n      return res;\n    },\n    [apiConfig, getContextString, contextCategories, textareaPurpose],\n  );\n}\n","export function retry<T>(\n  fn: () => Promise<T>,\n  retriesLeft: number = 2,\n  interval: number = 200,\n  backoff: number = 1.5,\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    fn()\n      .then(resolve)\n      .catch((error) => {\n        if (retriesLeft === 1) {\n          reject(error);\n          return;\n        }\n\n        setTimeout(() => {\n          retry(fn, retriesLeft - 1, interval * backoff, backoff)\n            .then(resolve)\n            .catch(reject);\n        }, interval);\n      });\n  });\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,wBAA+B;AAC/B,mBAAwC;;;ACFjC,SAAS,MACd,IACA,cAAsB,GACtB,WAAmB,KACnB,UAAkB,KACN;AACZ,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,OAAG,EACA,KAAK,OAAO,EACZ,MAAM,CAAC,UAAU;AAChB,UAAI,gBAAgB,GAAG;AACrB,eAAO,KAAK;AACZ;AAAA,MACF;AAEA,iBAAW,MAAM;AACf,cAAM,IAAI,cAAc,GAAG,WAAW,SAAS,OAAO,EACnD,KAAK,OAAO,EACZ,MAAM,MAAM;AAAA,MACjB,GAAG,QAAQ;AAAA,IACb,CAAC;AAAA,EACL,CAAC;AACH;;;ADfA,IAAAA,qBAAmD;AAe5C,SAAS,sCACd,iBACA,mBACA,WAC6B;AAC7B,QAAM,EAAE,kBAAkB,iBAAiB,QAAI,yBAAW,gCAAc;AAExE,aAAO;AAAA,IACL,CAAO,aAAmC,gBAA6B;AACrE,YAAM,MAAM,MAAM,MAAM,MAAY;AAClC,cAAM,WAAoC;AAAA,UACxC;AAAA,YACE,MAAM;AAAA,YACN,SAAS,UAAU;AAAA,cACjB;AAAA,cACA,iBAAiB,CAAC,GAAG,iBAAiB;AAAA,YACxC;AAAA,UACF;AAAA,UACA,GAAG,UAAU;AAAA,UACb;AAAA,YACE,MAAM;AAAA,YACN,MAAM;AAAA,YACN,SAAS,YAAY;AAAA,UACvB;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,MAAM;AAAA,YACN,SAAS,YAAY;AAAA,UACvB;AAAA,QACF;AAEA,cAAM,WAAW,UAAM,uDAAmC;AAAA,UACxD;AAAA,WACG,UAAU,kBAF2C;AAAA,UAGxD,eAAe;AAAA,UACf,QAAQ;AAAA,QACV,EAAC;AAED,YAAI,CAAC,SAAS,QAAQ;AACpB,gBAAM,IAAI,MAAM,iCAAiC;AAAA,QACnD;AAEA,cAAM,SAAS,SAAS,OAAO,UAAU;AAEzC,YAAI,SAAS;AACb,eAAO,CAAC,YAAY,SAAS;AAC3B,gBAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAC1C,cAAI,MAAM;AACR;AAAA,UACF;AACA,oBAAU;AAAA,QACZ;AACA,eAAO;AAAA,MACT,EAAC;AAED,aAAO;AAAA,IACT;AAAA,IACA,CAAC,WAAW,kBAAkB,mBAAmB,eAAe;AAAA,EAClE;AACF;","names":["import_react_core"]}