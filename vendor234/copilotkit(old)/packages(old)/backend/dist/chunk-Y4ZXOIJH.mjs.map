{"version":3,"sources":["../src/utils/langserve.ts"],"sourcesContent":["import { AnnotatedFunction } from \"@copilotkit/shared\";\nimport { RemoteChain } from \"../types\";\nimport { RemoteRunnable } from \"langchain/runnables/remote\";\n\nexport async function remoteChainToAnnotatedFunction(\n  chain: RemoteChain,\n): Promise<AnnotatedFunction<any[]>> {\n  chain = { ...chain };\n  const runnable = new RemoteRunnable({ url: chain.chainUrl });\n\n  if (!chain.argumentAnnotations) {\n    chain = await inferLangServeParameters(chain);\n  }\n\n  chain.argumentType ||= \"multi\";\n\n  return {\n    name: chain.name,\n    description: chain.description,\n    argumentAnnotations: chain.argumentAnnotations!,\n    implementation: async (...args: any[]) => {\n      let input: any;\n      if (chain.argumentType === \"single\") {\n        input = args[0];\n      } else {\n        input = {};\n        for (let i = 0; i < args.length; i++) {\n          input[chain.argumentAnnotations![i].name] = args[i];\n        }\n      }\n      return await runnable.invoke(input);\n    },\n  };\n}\n\nexport async function inferLangServeParameters(chain: RemoteChain): Promise<RemoteChain> {\n  chain = { ...chain };\n\n  const supportedTypes = [\"string\", \"number\", \"boolean\"];\n\n  let schemaUrl = chain.chainUrl.replace(/\\/+$/, \"\") + \"/input_schema\";\n  let schema = await fetch(schemaUrl)\n    .then((res) => res.json())\n    .catch(() => {\n      throw new Error(\"Failed to fetch langserve schema at \" + schemaUrl);\n    });\n  // for now, don't use json schema, just do a simple conversion\n\n  if (supportedTypes.includes(schema.type)) {\n    chain.argumentType = \"single\";\n    chain.argumentAnnotations = [\n      {\n        name: \"input\",\n        type: schema.type,\n        description: \"The input to the chain\",\n        required: true,\n      },\n    ];\n  } else if (schema.type === \"object\") {\n    chain.argumentType = \"multi\";\n    chain.argumentAnnotations = Object.keys(schema.properties).map((key) => {\n      let property = schema.properties[key];\n      if (!supportedTypes.includes(property.type)) {\n        throw new Error(\"Unsupported schema type\");\n      }\n      return {\n        name: key,\n        type: property.type,\n        description: property.description || \"\",\n        required: schema.required?.includes(key) || false,\n      };\n    });\n  } else {\n    throw new Error(\"Unsupported schema type\");\n  }\n\n  return chain;\n}\n"],"mappings":";AAEA,SAAS,sBAAsB;AAE/B,eAAsB,+BACpB,OACmC;AACnC,UAAQ,EAAE,GAAG,MAAM;AACnB,QAAM,WAAW,IAAI,eAAe,EAAE,KAAK,MAAM,SAAS,CAAC;AAE3D,MAAI,CAAC,MAAM,qBAAqB;AAC9B,YAAQ,MAAM,yBAAyB,KAAK;AAAA,EAC9C;AAEA,QAAM,iBAAN,MAAM,eAAiB;AAEvB,SAAO;AAAA,IACL,MAAM,MAAM;AAAA,IACZ,aAAa,MAAM;AAAA,IACnB,qBAAqB,MAAM;AAAA,IAC3B,gBAAgB,UAAU,SAAgB;AACxC,UAAI;AACJ,UAAI,MAAM,iBAAiB,UAAU;AACnC,gBAAQ,KAAK,CAAC;AAAA,MAChB,OAAO;AACL,gBAAQ,CAAC;AACT,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,gBAAM,MAAM,oBAAqB,CAAC,EAAE,IAAI,IAAI,KAAK,CAAC;AAAA,QACpD;AAAA,MACF;AACA,aAAO,MAAM,SAAS,OAAO,KAAK;AAAA,IACpC;AAAA,EACF;AACF;AAEA,eAAsB,yBAAyB,OAA0C;AACvF,UAAQ,EAAE,GAAG,MAAM;AAEnB,QAAM,iBAAiB,CAAC,UAAU,UAAU,SAAS;AAErD,MAAI,YAAY,MAAM,SAAS,QAAQ,QAAQ,EAAE,IAAI;AACrD,MAAI,SAAS,MAAM,MAAM,SAAS,EAC/B,KAAK,CAAC,QAAQ,IAAI,KAAK,CAAC,EACxB,MAAM,MAAM;AACX,UAAM,IAAI,MAAM,yCAAyC,SAAS;AAAA,EACpE,CAAC;AAGH,MAAI,eAAe,SAAS,OAAO,IAAI,GAAG;AACxC,UAAM,eAAe;AACrB,UAAM,sBAAsB;AAAA,MAC1B;AAAA,QACE,MAAM;AAAA,QACN,MAAM,OAAO;AAAA,QACb,aAAa;AAAA,QACb,UAAU;AAAA,MACZ;AAAA,IACF;AAAA,EACF,WAAW,OAAO,SAAS,UAAU;AACnC,UAAM,eAAe;AACrB,UAAM,sBAAsB,OAAO,KAAK,OAAO,UAAU,EAAE,IAAI,CAAC,QAAQ;AA5D5E;AA6DM,UAAI,WAAW,OAAO,WAAW,GAAG;AACpC,UAAI,CAAC,eAAe,SAAS,SAAS,IAAI,GAAG;AAC3C,cAAM,IAAI,MAAM,yBAAyB;AAAA,MAC3C;AACA,aAAO;AAAA,QACL,MAAM;AAAA,QACN,MAAM,SAAS;AAAA,QACf,aAAa,SAAS,eAAe;AAAA,QACrC,YAAU,YAAO,aAAP,mBAAiB,SAAS,SAAQ;AAAA,MAC9C;AAAA,IACF,CAAC;AAAA,EACH,OAAO;AACL,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAEA,SAAO;AACT;","names":[]}