{"version":3,"sources":["../../src/utils/parse-chat-completion.ts"],"sourcesContent":["import { Role } from \"../types/openai-assistant\";\n\nexport interface ChatCompletionChunk {\n  choices: {\n    delta: {\n      role: Role;\n      content?: string | null;\n\n      // TODO:\n      // Temporarily add name to the OpenAI protocol until we\n      // have our own protocol.\n      // When name is set, we return the result of a server-side\n      // function call.\n      name?: string;\n\n      function_call?: {\n        name?: string;\n        arguments?: string;\n      };\n      tool_calls?: {\n        index: number;\n        id?: string;\n        function: {\n          arguments?: string;\n\n          name?: string;\n          // TODO:\n          // Temporarily add scope to the OpenAI protocol until we\n          // have our own protocol.\n          // When scope is \"server\", the client will not attempt to\n          // execute the function.\n          scope?: \"client\" | \"server\";\n        };\n      }[];\n    };\n  }[];\n}\n\n// TODO:\n// it's possible that unicode characters could be split across chunks\n// make sure to properly handle that\nexport function parseChatCompletion(\n  stream: ReadableStream<Uint8Array>,\n): ReadableStream<ChatCompletionChunk> {\n  const reader = stream.getReader();\n  let buffer = new Uint8Array();\n\n  async function cleanup(controller?: ReadableStreamDefaultController<any>) {\n    if (controller) {\n      try {\n        controller.close();\n      } catch (_) {}\n    }\n    if (reader) {\n      try {\n        await reader.cancel();\n      } catch (_) {}\n    }\n  }\n\n  return new ReadableStream<ChatCompletionChunk>({\n    async pull(controller) {\n      while (true) {\n        try {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            await cleanup(controller);\n            return;\n          }\n\n          const newBuffer = new Uint8Array(buffer.length + value.length);\n          newBuffer.set(buffer);\n          newBuffer.set(value, buffer.length);\n          buffer = newBuffer;\n\n          const valueString = new TextDecoder(\"utf-8\").decode(buffer);\n          const lines = valueString.split(\"\\n\").filter((line) => line.trim() !== \"\");\n\n          // If the last line isn't complete, keep it in the buffer for next time\n          buffer = !valueString.endsWith(\"\\n\")\n            ? new TextEncoder().encode(lines.pop() || \"\")\n            : new Uint8Array();\n\n          for (const line of lines) {\n            const cleanedLine = line.replace(/^data: /, \"\");\n\n            if (cleanedLine === \"[DONE]\") {\n              await cleanup(controller);\n              return;\n            }\n\n            const json = JSON.parse(cleanedLine);\n            controller.enqueue(json);\n          }\n        } catch (error) {\n          controller.error(error);\n          await cleanup(controller);\n          return;\n        }\n      }\n    },\n    cancel() {\n      reader.cancel();\n    },\n  });\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAyCO,SAAS,oBACd,QACqC;AACrC,QAAM,SAAS,OAAO,UAAU;AAChC,MAAI,SAAS,IAAI,WAAW;AAE5B,iBAAe,QAAQ,YAAmD;AACxE,QAAI,YAAY;AACd,UAAI;AACF,mBAAW,MAAM;AAAA,MACnB,SAAS,GAAP;AAAA,MAAW;AAAA,IACf;AACA,QAAI,QAAQ;AACV,UAAI;AACF,cAAM,OAAO,OAAO;AAAA,MACtB,SAAS,GAAP;AAAA,MAAW;AAAA,IACf;AAAA,EACF;AAEA,SAAO,IAAI,eAAoC;AAAA,IAC7C,MAAM,KAAK,YAAY;AACrB,aAAO,MAAM;AACX,YAAI;AACF,gBAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAE1C,cAAI,MAAM;AACR,kBAAM,QAAQ,UAAU;AACxB;AAAA,UACF;AAEA,gBAAM,YAAY,IAAI,WAAW,OAAO,SAAS,MAAM,MAAM;AAC7D,oBAAU,IAAI,MAAM;AACpB,oBAAU,IAAI,OAAO,OAAO,MAAM;AAClC,mBAAS;AAET,gBAAM,cAAc,IAAI,YAAY,OAAO,EAAE,OAAO,MAAM;AAC1D,gBAAM,QAAQ,YAAY,MAAM,IAAI,EAAE,OAAO,CAAC,SAAS,KAAK,KAAK,MAAM,EAAE;AAGzE,mBAAS,CAAC,YAAY,SAAS,IAAI,IAC/B,IAAI,YAAY,EAAE,OAAO,MAAM,IAAI,KAAK,EAAE,IAC1C,IAAI,WAAW;AAEnB,qBAAW,QAAQ,OAAO;AACxB,kBAAM,cAAc,KAAK,QAAQ,WAAW,EAAE;AAE9C,gBAAI,gBAAgB,UAAU;AAC5B,oBAAM,QAAQ,UAAU;AACxB;AAAA,YACF;AAEA,kBAAM,OAAO,KAAK,MAAM,WAAW;AACnC,uBAAW,QAAQ,IAAI;AAAA,UACzB;AAAA,QACF,SAAS,OAAP;AACA,qBAAW,MAAM,KAAK;AACtB,gBAAM,QAAQ,UAAU;AACxB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA,SAAS;AACP,aAAO,OAAO;AAAA,IAChB;AAAA,EACF,CAAC;AACH;","names":[]}