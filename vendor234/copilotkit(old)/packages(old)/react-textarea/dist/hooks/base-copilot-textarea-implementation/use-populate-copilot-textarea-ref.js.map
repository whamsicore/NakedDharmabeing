{"version":3,"sources":["../../../src/hooks/base-copilot-textarea-implementation/use-populate-copilot-textarea-ref.ts","../../../src/lib/get-text-around-cursor.ts","../../../src/lib/slatejs-edits/replace-text.ts"],"sourcesContent":["import React from \"react\";\nimport { Editor } from \"slate\";\nimport { ReactEditor } from \"slate-react\";\nimport { getFullEditorTextWithNewlines } from \"../../lib/get-text-around-cursor\";\nimport { replaceEditorText } from \"../../lib/slatejs-edits/replace-text\";\nimport { HTMLCopilotTextAreaElement } from \"../../types\";\nimport { CustomEditor } from \"../../types/base/custom-editor\";\n\nexport function usePopulateCopilotTextareaRef(\n  editor: Editor,\n  ref: React.Ref<HTMLCopilotTextAreaElement>,\n) {\n  React.useImperativeHandle(\n    ref,\n    () => {\n      class Combined {\n        constructor(private customMethods: CustomMethods, private editorHtmlElement: HTMLElement) {}\n\n        [key: string]: any;\n\n        get(target: any, propKey: string): any {\n          if (this.isKeyOfCustomMethods(propKey)) {\n            const value = this.customMethods[propKey];\n            if (typeof value === \"function\") {\n              return value.bind(this.customMethods);\n            }\n            return value;\n          } else if (this.isKeyOfHTMLElement(propKey)) {\n            const value = this.editorHtmlElement[propKey];\n            if (typeof value === \"function\") {\n              return value.bind(this.editorHtmlElement);\n            }\n            return value;\n          }\n        }\n\n        set(target: any, propKey: string, value: any): boolean {\n          if (this.isKeyOfCustomMethods(propKey)) {\n            (this.customMethods as any)[propKey] = value;\n          } else if (this.isKeyOfHTMLElement(propKey)) {\n            (this.editorHtmlElement as any)[propKey] = value;\n          } else {\n            // Default behavior (optional)\n            target[propKey] = value;\n          }\n          return true;\n        }\n\n        private isKeyOfCustomMethods(key: string): key is keyof CustomMethods {\n          return key in this.customMethods;\n        }\n\n        private isKeyOfHTMLElement(key: string): key is keyof HTMLElement {\n          return key in this.editorHtmlElement;\n        }\n      }\n\n      const handler = {\n        get(target: any, propKey: keyof CustomMethods | keyof HTMLElement) {\n          return target.get(target, propKey);\n        },\n        set(target: any, propKey: keyof CustomMethods | keyof HTMLElement, value: any) {\n          return target.set(target, propKey, value);\n        },\n      };\n\n      class CustomMethods {\n        constructor(private editor: CustomEditor) {}\n\n        focus() {\n          ReactEditor.focus(this.editor);\n        }\n\n        blur() {\n          ReactEditor.blur(this.editor);\n        }\n\n        get value() {\n          return getFullEditorTextWithNewlines(this.editor);\n        }\n        set value(value: string) {\n          replaceEditorText(this.editor, value);\n        }\n      }\n\n      const editorHtmlElement = ReactEditor.toDOMNode(editor, editor);\n      const customMethods = new CustomMethods(editor);\n\n      const combined = new Combined(customMethods, editorHtmlElement);\n      return new Proxy(combined, handler);\n    },\n    [editor],\n  );\n}\n","import { Editor, Node, Path, Range, Text, Element, BasePoint, BaseRange, Point } from \"slate\";\nimport { EditorAutocompleteState } from \"../types/base/editor-autocomplete-state\";\n\nexport interface EditorTextState {\n  selection: BaseRange;\n\n  textBeforeCursor: string;\n  selectedText: string;\n  textAfterCursor: string;\n}\n\nexport function getTextAroundCollapsedCursor(editor: Editor): EditorAutocompleteState | null {\n  const { selection } = editor;\n  if (!selection || !Range.isCollapsed(selection)) {\n    return null;\n  }\n\n  const cursorPoint = selection.anchor;\n\n  // Create two ranges: one before the anchor and one after\n  const beforeRange: Range = {\n    anchor: Editor.start(editor, []),\n    focus: cursorPoint,\n  };\n  const afterRange: Range = {\n    anchor: cursorPoint,\n    focus: Editor.end(editor, []),\n  };\n\n  // Extract text for these ranges\n  const before = extractTextWithNewlines(editor, beforeRange);\n  const after = extractTextWithNewlines(editor, afterRange);\n\n  return {\n    cursorPoint: cursorPoint,\n    textBeforeCursor: before,\n    textAfterCursor: after,\n  };\n}\n\nexport function getTextAroundSelection(editor: Editor): EditorTextState | null {\n  const { selection } = editor;\n  if (!selection) {\n    return null;\n  }\n\n  const wellOrderedSelection = wellOrderedRange(selection);\n\n  // Create two ranges: one before the anchor and one after\n  const beforeRange: Range = {\n    anchor: Editor.start(editor, []),\n    focus: wellOrderedSelection.anchor,\n  };\n  const afterRange: Range = {\n    anchor: wellOrderedSelection.focus,\n    focus: Editor.end(editor, []),\n  };\n\n  // Extract text for these ranges\n  const before = extractTextWithNewlines(editor, beforeRange);\n  const after = extractTextWithNewlines(editor, afterRange);\n  const selectedText = extractTextWithNewlines(editor, wellOrderedSelection);\n\n  return {\n    selection: wellOrderedSelection,\n    textBeforeCursor: before,\n    selectedText,\n    textAfterCursor: after,\n  };\n}\n\nexport function getFullEditorTextWithNewlines(editor: Editor): string {\n  const fullDocumentRange: Range = {\n    anchor: Editor.start(editor, []),\n    focus: Editor.end(editor, []),\n  };\n  return extractTextWithNewlines(editor, fullDocumentRange);\n}\n\n// Helper function to extract text with newlines\nexport function extractTextWithNewlines(editor: Editor, range: Range): string {\n  const voids = false;\n  const [start, end] = Range.edges(range);\n  let text = \"\";\n  let lastBlock: Node | null = null;\n\n  for (const [node, path] of Editor.nodes(editor, {\n    at: range,\n    match: Text.isText,\n    voids,\n  })) {\n    let t = node.text;\n\n    // Determine the parent block of the current text node\n    const [block] = Editor.above(editor, {\n      at: path,\n      match: (n) => Element.isElement(n) && n.type === \"paragraph\",\n    }) || [null];\n\n    // If we encounter a new block, prepend a newline\n    if (lastBlock !== block && block) {\n      // check that lastBlock is not null to avoid adding a newline at the beginning\n      if (lastBlock) {\n        text += \"\\n\";\n      }\n      lastBlock = block;\n    }\n\n    if (Path.equals(path, end.path)) {\n      t = t.slice(0, end.offset);\n    }\n\n    if (Path.equals(path, start.path)) {\n      t = t.slice(start.offset);\n    }\n\n    text += t;\n  }\n\n  return text;\n}\n\nfunction wellOrderedRange(range: BaseRange): BaseRange {\n  const { anchor, focus } = range;\n  // if anchor is before focus, return range as is\n  if (Point.isBefore(anchor, focus)) {\n    return range;\n  }\n\n  // if focus is before anchor, return range with anchor and focus swapped\n  return {\n    anchor: focus,\n    focus: anchor,\n  };\n}\n","import { Editor, Transforms } from \"slate\";\n\nexport function replaceEditorText(editor: Editor, newText: string) {\n  // clear all previous text\n  Transforms.delete(editor, {\n    at: {\n      anchor: Editor.start(editor, []),\n      focus: Editor.end(editor, []),\n    },\n  });\n\n  // insert new text\n  if (newText && newText !== \"\") {\n    // don't insert empty text - results in strange visual behavior\n    Transforms.insertNodes(\n      editor,\n      [\n        {\n          type: \"paragraph\",\n          children: [{ text: newText }],\n        },\n      ],\n      {\n        at: [0],\n      },\n    );\n  }\n}\n"],"mappings":"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","names":["import_slate","React","customMethods","editorHtmlElement","editor"]}