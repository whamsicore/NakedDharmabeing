{"version":3,"sources":["../../../src/hooks/base-copilot-textarea-implementation/use-autosuggestions.ts","../../../src/lib/debouncer.ts","../../../src/lib/utils.ts","../../../src/types/base/editor-autocomplete-state.ts"],"sourcesContent":["import { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { Debouncer } from \"../../lib/debouncer\";\nimport { nullableCompatibleEqualityCheck } from \"../../lib/utils\";\nimport { AutosuggestionsBareFunction } from \"../../types/base\";\nimport { AutosuggestionState } from \"../../types/base/autosuggestion-state\";\nimport {\n  EditorAutocompleteState,\n  areEqual_autocompleteState,\n} from \"../../types/base/editor-autocomplete-state\";\n\nexport interface UseAutosuggestionsResult {\n  currentAutocompleteSuggestion: AutosuggestionState | null;\n  onChangeHandler: (newEditorState: EditorAutocompleteState | null) => void;\n  onKeyDownHandler: (event: React.KeyboardEvent<HTMLDivElement>) => void;\n}\n\nexport function useAutosuggestions(\n  debounceTime: number,\n  shouldAcceptAutosuggestionOnKeyPress: (event: React.KeyboardEvent<HTMLDivElement>) => boolean,\n  autosuggestionFunction: AutosuggestionsBareFunction,\n  insertAutocompleteSuggestion: (suggestion: AutosuggestionState) => void,\n  disableWhenEmpty: boolean,\n  disabled: boolean,\n): UseAutosuggestionsResult {\n  const [previousAutocompleteState, setPreviousAutocompleteState] =\n    useState<EditorAutocompleteState | null>(null);\n\n  const [currentAutocompleteSuggestion, setCurrentAutocompleteSuggestion] =\n    useState<AutosuggestionState | null>(null);\n\n  const awaitForAndAppendSuggestion: (\n    editorAutocompleteState: EditorAutocompleteState,\n    abortSignal: AbortSignal,\n  ) => Promise<void> = useCallback(\n    async (editorAutocompleteState: EditorAutocompleteState, abortSignal: AbortSignal) => {\n      // early return if disabled\n      if (disabled) {\n        return;\n      }\n\n      if (\n        disableWhenEmpty &&\n        editorAutocompleteState.textBeforeCursor === \"\" &&\n        editorAutocompleteState.textAfterCursor === \"\"\n      ) {\n        return;\n      }\n\n      // fetch the suggestion\n      const suggestion = await autosuggestionFunction(editorAutocompleteState, abortSignal);\n\n      // We'll assume for now that the autocomplete function might or might not respect the abort signal.\n      if (!suggestion || abortSignal.aborted) {\n        throw new DOMException(\"Aborted\", \"AbortError\");\n      }\n\n      setCurrentAutocompleteSuggestion({\n        text: suggestion,\n        point: editorAutocompleteState.cursorPoint,\n      });\n    },\n    [autosuggestionFunction, setCurrentAutocompleteSuggestion, disableWhenEmpty, disabled],\n  );\n\n  const debouncedFunction = useMemo(\n    () => new Debouncer<[editorAutocompleteState: EditorAutocompleteState]>(debounceTime),\n    [debounceTime],\n  );\n\n  // clean current state when unmounting or disabling\n  useEffect(() => {\n    return () => {\n      debouncedFunction.cancel();\n      setCurrentAutocompleteSuggestion(null);\n    };\n  }, [debouncedFunction, disabled]);\n\n  const onChange = useCallback(\n    (newEditorState: EditorAutocompleteState | null) => {\n      const editorStateHasChanged = !nullableCompatibleEqualityCheck(\n        areEqual_autocompleteState,\n        previousAutocompleteState,\n        newEditorState,\n      );\n      setPreviousAutocompleteState(newEditorState);\n\n      // if no change, do nothing\n      if (!editorStateHasChanged) {\n        return;\n      }\n\n      // if change, then first null out the current suggestion\n      setCurrentAutocompleteSuggestion(null);\n\n      // then try to get a new suggestion, debouncing to avoid too many requests while typing\n      if (newEditorState) {\n        debouncedFunction.debounce(awaitForAndAppendSuggestion, newEditorState);\n      } else {\n        debouncedFunction.cancel();\n      }\n    },\n    [\n      previousAutocompleteState,\n      setPreviousAutocompleteState,\n      debouncedFunction,\n      awaitForAndAppendSuggestion,\n      setCurrentAutocompleteSuggestion,\n    ],\n  );\n\n  const keyDownHandler = useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      if (currentAutocompleteSuggestion) {\n        if (shouldAcceptAutosuggestionOnKeyPress(event)) {\n          event.preventDefault();\n          insertAutocompleteSuggestion(currentAutocompleteSuggestion);\n          setCurrentAutocompleteSuggestion(null);\n        }\n      }\n    },\n    [\n      currentAutocompleteSuggestion,\n      setCurrentAutocompleteSuggestion,\n      insertAutocompleteSuggestion,\n      shouldAcceptAutosuggestionOnKeyPress,\n    ],\n  );\n\n  return {\n    currentAutocompleteSuggestion,\n    onChangeHandler: onChange,\n    onKeyDownHandler: keyDownHandler,\n  };\n}\n","export type AsyncFunction<T extends any[]> = (...args: [...T, AbortSignal]) => Promise<void>;\n\nexport class Debouncer<T extends any[]> {\n  private timeoutId?: ReturnType<typeof setTimeout>;\n  private activeAbortController?: AbortController;\n\n  constructor(private wait: number) {}\n\n  debounce = async (func: AsyncFunction<T>, ...args: T) => {\n    // Abort the previous promise immediately\n    this.cancel();\n\n    this.timeoutId = setTimeout(async () => {\n      try {\n        this.activeAbortController = new AbortController();\n\n        // Pass the signal to the async function, assuming it supports it\n        await func(...args, this.activeAbortController.signal);\n\n        this.activeAbortController = undefined;\n      } catch (error) {}\n    }, this.wait);\n  };\n\n  cancel = () => {\n    if (this.activeAbortController) {\n      this.activeAbortController.abort();\n      this.activeAbortController = undefined;\n    }\n\n    if (this.timeoutId !== undefined) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = undefined;\n    }\n  };\n}\n","import { clsx, type ClassValue } from \"clsx\";\nimport { customAlphabet } from \"nanoid\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport const nanoid = customAlphabet(\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  7,\n); // 7-character random string\n\nexport async function fetcher<JSON = any>(input: RequestInfo, init?: RequestInit): Promise<JSON> {\n  const res = await fetch(input, init);\n\n  if (!res.ok) {\n    const json = await res.json();\n    if (json.error) {\n      const error = new Error(json.error) as Error & {\n        status: number;\n      };\n      error.status = res.status;\n      throw error;\n    } else {\n      throw new Error(\"An unexpected error occurred\");\n    }\n  }\n\n  return res.json();\n}\n\nexport function formatDate(input: string | number | Date): string {\n  const date = new Date(input);\n  return date.toLocaleDateString(\"en-US\", {\n    month: \"long\",\n    day: \"numeric\",\n    year: \"numeric\",\n  });\n}\n\nexport const arraysAreEqual = (arr1: number[], arr2: number[]): boolean =>\n  arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);\n\nexport function nullableCompatibleEqualityCheck<T>(\n  naiveEqualityCheck: (a: T, b: T) => boolean,\n  a: T | null | undefined,\n  b: T | null | undefined,\n): boolean {\n  if (a === null || a === undefined || b === null || b === undefined) {\n    return a === b;\n  }\n\n  return naiveEqualityCheck(a, b);\n}\n","import { BasePoint } from \"slate\";\nimport { arraysAreEqual } from \"../../lib/utils\";\n\nexport interface EditorAutocompleteState {\n  cursorPoint: BasePoint;\n  textBeforeCursor: string;\n  textAfterCursor: string;\n}\n\nexport function areEqual_autocompleteState(\n  prev: EditorAutocompleteState,\n  next: EditorAutocompleteState,\n) {\n  return (\n    prev.cursorPoint.offset === next.cursorPoint.offset &&\n    arraysAreEqual(prev.cursorPoint.path, next.cursorPoint.path) &&\n    prev.textBeforeCursor === next.textBeforeCursor &&\n    prev.textAfterCursor === next.textAfterCursor\n  );\n}\n"],"mappings":"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","names":[]}