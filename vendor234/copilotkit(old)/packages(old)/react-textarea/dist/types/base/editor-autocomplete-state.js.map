{"version":3,"sources":["../../../src/types/base/editor-autocomplete-state.ts","../../../src/lib/utils.ts"],"sourcesContent":["import { BasePoint } from \"slate\";\nimport { arraysAreEqual } from \"../../lib/utils\";\n\nexport interface EditorAutocompleteState {\n  cursorPoint: BasePoint;\n  textBeforeCursor: string;\n  textAfterCursor: string;\n}\n\nexport function areEqual_autocompleteState(\n  prev: EditorAutocompleteState,\n  next: EditorAutocompleteState,\n) {\n  return (\n    prev.cursorPoint.offset === next.cursorPoint.offset &&\n    arraysAreEqual(prev.cursorPoint.path, next.cursorPoint.path) &&\n    prev.textBeforeCursor === next.textBeforeCursor &&\n    prev.textAfterCursor === next.textAfterCursor\n  );\n}\n","import { clsx, type ClassValue } from \"clsx\";\nimport { customAlphabet } from \"nanoid\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport const nanoid = customAlphabet(\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  7,\n); // 7-character random string\n\nexport async function fetcher<JSON = any>(input: RequestInfo, init?: RequestInit): Promise<JSON> {\n  const res = await fetch(input, init);\n\n  if (!res.ok) {\n    const json = await res.json();\n    if (json.error) {\n      const error = new Error(json.error) as Error & {\n        status: number;\n      };\n      error.status = res.status;\n      throw error;\n    } else {\n      throw new Error(\"An unexpected error occurred\");\n    }\n  }\n\n  return res.json();\n}\n\nexport function formatDate(input: string | number | Date): string {\n  const date = new Date(input);\n  return date.toLocaleDateString(\"en-US\", {\n    month: \"long\",\n    day: \"numeric\",\n    year: \"numeric\",\n  });\n}\n\nexport const arraysAreEqual = (arr1: number[], arr2: number[]): boolean =>\n  arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);\n\nexport function nullableCompatibleEqualityCheck<T>(\n  naiveEqualityCheck: (a: T, b: T) => boolean,\n  a: T | null | undefined,\n  b: T | null | undefined,\n): boolean {\n  if (a === null || a === undefined || b === null || b === undefined) {\n    return a === b;\n  }\n\n  return naiveEqualityCheck(a, b);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,kBAAsC;AACtC,oBAA+B;AAC/B,4BAAwB;AAMjB,IAAM,aAAS;AAAA,EACpB;AAAA,EACA;AACF;AA8BO,IAAM,iBAAiB,CAAC,MAAgB,SAC7C,KAAK,WAAW,KAAK,UAAU,KAAK,MAAM,CAAC,OAAO,UAAU,UAAU,KAAK,KAAK,CAAC;;;ADjC5E,SAAS,2BACd,MACA,MACA;AACA,SACE,KAAK,YAAY,WAAW,KAAK,YAAY,UAC7C,eAAe,KAAK,YAAY,MAAM,KAAK,YAAY,IAAI,KAC3D,KAAK,qBAAqB,KAAK,oBAC/B,KAAK,oBAAoB,KAAK;AAElC;","names":[]}