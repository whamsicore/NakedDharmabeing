{"version":3,"sources":["../../../src/components/base-copilot-textarea/track-cursor-moved-since-last-text-change.tsx","../../../src/lib/editor-to-text.ts"],"sourcesContent":["import { useEffect, useRef } from \"react\";\nimport { BaseSelection } from \"slate\";\nimport { useSlateSelector } from \"slate-react\";\nimport { Range } from \"slate\";\nimport { editorToText } from \"../../lib/editor-to-text\";\n\ninterface TrackerTextEditedSinceLastCursorMovementProps {\n  setCursorMovedSinceLastTextChange: (value: boolean) => void;\n}\nexport function TrackerTextEditedSinceLastCursorMovement(\n  props: TrackerTextEditedSinceLastCursorMovementProps,\n) {\n  const cursorState: RelevantEditorState = useSlateSelector((state) => ({\n    selection: state.selection,\n    text: editorToText(state),\n  }));\n\n  const previousState = usePrevious(cursorState);\n\n  useEffect(() => {\n    if (!previousState) {\n      return;\n    }\n\n    if (cursorChangedWithoutTextChanged(previousState, cursorState)) {\n      props.setCursorMovedSinceLastTextChange(true);\n    }\n  }, [props.setCursorMovedSinceLastTextChange, cursorState]);\n\n  return <></>;\n}\n\ntype RelevantEditorState = {\n  selection: BaseSelection;\n  text: string;\n};\n\nconst cursorChangedWithoutTextChanged = (\n  prev: RelevantEditorState,\n  next: RelevantEditorState,\n): boolean => {\n  // Check if the selection has changed\n  const isSelectionChanged = !isSelectionEqual(prev.selection, next.selection);\n\n  // Check if the text content remains the same\n  const isTextSame = prev.text === next.text;\n\n  return isSelectionChanged && isTextSame;\n};\n\nconst isSelectionEqual = (a: BaseSelection, b: BaseSelection) => {\n  if (!a && !b) return true;\n  if (!a || !b) return false;\n  return Range.equals(a, b);\n};\n\n/**\n * Easily keep track of the *previous* value of a variable.\n *\n * Example:\n * ```\n * const [count, setCount] = useState(0);\n * const prevCount = usePrevious(count);\n *\n * useEffect(() => {\n *  if (count > prevCount) {\n *   console.log('Now I know that count is bigger than before');\n * }\n * }, [count, prevCount]);\n * ```\n */\nfunction usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>();\n\n  useEffect(() => {\n    ref.current = value;\n  });\n\n  return ref.current;\n}\n","import { BaseEditor, Descendant, Element } from \"slate\";\nimport { HistoryEditor } from \"slate-history\";\nimport { ReactEditor } from \"slate-react\";\nimport { SuggestionAwareText } from \"../types/base/custom-editor\";\n\nfunction nodeChildrenToTextComponents(\n  editor: BaseEditor & ReactEditor & HistoryEditor,\n  nodes: Descendant[],\n): SuggestionAwareText[] {\n  // find inlineable elements\n  const indeciesOfInlineElements = new Set(\n    nodes\n      .map((node, index) => {\n        if (Element.isElement(node) && editor.isInline(node)) {\n          return index;\n        }\n        return -1;\n      })\n      .filter((index) => index !== -1),\n  );\n\n  // ignorable elements = inline elements,\n  // or neighbors of inline elements that are {text: \"\"}\n  const nonIgnorableItems = nodes.filter((node, index) => {\n    const isInline = indeciesOfInlineElements.has(index);\n    if (isInline) {\n      return false;\n    }\n\n    const isNeighbourOfInline =\n      indeciesOfInlineElements.has(index - 1) || indeciesOfInlineElements.has(index + 1);\n    if (isNeighbourOfInline) {\n      return (node as any).text !== \"\";\n    }\n\n    return true;\n  });\n\n  return nonIgnorableItems\n    .map((node) => {\n      if (Element.isElement(node)) {\n        switch (node.type) {\n          case \"paragraph\":\n            return nodeChildrenToTextComponents(editor, node.children);\n          case \"suggestion\":\n            return [];\n        }\n      } else {\n        return [node];\n      }\n    })\n    .reduce((acc, val) => acc.concat(val), []);\n}\n\nexport const editorToText = (editor: BaseEditor & ReactEditor & HistoryEditor) => {\n  const flattened = nodeChildrenToTextComponents(editor, editor.children);\n\n  const text = flattened.map((textComponent) => textComponent.text).join(\"\\n\");\n\n  return text;\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAkC;AAElC,yBAAiC;AACjC,IAAAA,gBAAsB;;;ACHtB,mBAAgD;AAKhD,SAAS,6BACP,QACA,OACuB;AAEvB,QAAM,2BAA2B,IAAI;AAAA,IACnC,MACG,IAAI,CAAC,MAAM,UAAU;AACpB,UAAI,qBAAQ,UAAU,IAAI,KAAK,OAAO,SAAS,IAAI,GAAG;AACpD,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT,CAAC,EACA,OAAO,CAAC,UAAU,UAAU,EAAE;AAAA,EACnC;AAIA,QAAM,oBAAoB,MAAM,OAAO,CAAC,MAAM,UAAU;AACtD,UAAM,WAAW,yBAAyB,IAAI,KAAK;AACnD,QAAI,UAAU;AACZ,aAAO;AAAA,IACT;AAEA,UAAM,sBACJ,yBAAyB,IAAI,QAAQ,CAAC,KAAK,yBAAyB,IAAI,QAAQ,CAAC;AACnF,QAAI,qBAAqB;AACvB,aAAQ,KAAa,SAAS;AAAA,IAChC;AAEA,WAAO;AAAA,EACT,CAAC;AAED,SAAO,kBACJ,IAAI,CAAC,SAAS;AACb,QAAI,qBAAQ,UAAU,IAAI,GAAG;AAC3B,cAAQ,KAAK,MAAM;AAAA,QACjB,KAAK;AACH,iBAAO,6BAA6B,QAAQ,KAAK,QAAQ;AAAA,QAC3D,KAAK;AACH,iBAAO,CAAC;AAAA,MACZ;AAAA,IACF,OAAO;AACL,aAAO,CAAC,IAAI;AAAA,IACd;AAAA,EACF,CAAC,EACA,OAAO,CAAC,KAAK,QAAQ,IAAI,OAAO,GAAG,GAAG,CAAC,CAAC;AAC7C;AAEO,IAAM,eAAe,CAAC,WAAqD;AAChF,QAAM,YAAY,6BAA6B,QAAQ,OAAO,QAAQ;AAEtE,QAAM,OAAO,UAAU,IAAI,CAAC,kBAAkB,cAAc,IAAI,EAAE,KAAK,IAAI;AAE3E,SAAO;AACT;;;AD/BS;AApBF,SAAS,yCACd,OACA;AACA,QAAM,kBAAmC,qCAAiB,CAAC,WAAW;AAAA,IACpE,WAAW,MAAM;AAAA,IACjB,MAAM,aAAa,KAAK;AAAA,EAC1B,EAAE;AAEF,QAAM,gBAAgB,YAAY,WAAW;AAE7C,8BAAU,MAAM;AACd,QAAI,CAAC,eAAe;AAClB;AAAA,IACF;AAEA,QAAI,gCAAgC,eAAe,WAAW,GAAG;AAC/D,YAAM,kCAAkC,IAAI;AAAA,IAC9C;AAAA,EACF,GAAG,CAAC,MAAM,mCAAmC,WAAW,CAAC;AAEzD,SAAO,2EAAE;AACX;AAOA,IAAM,kCAAkC,CACtC,MACA,SACY;AAEZ,QAAM,qBAAqB,CAAC,iBAAiB,KAAK,WAAW,KAAK,SAAS;AAG3E,QAAM,aAAa,KAAK,SAAS,KAAK;AAEtC,SAAO,sBAAsB;AAC/B;AAEA,IAAM,mBAAmB,CAAC,GAAkB,MAAqB;AAC/D,MAAI,CAAC,KAAK,CAAC;AAAG,WAAO;AACrB,MAAI,CAAC,KAAK,CAAC;AAAG,WAAO;AACrB,SAAO,oBAAM,OAAO,GAAG,CAAC;AAC1B;AAiBA,SAAS,YAAe,OAAyB;AAC/C,QAAM,UAAM,qBAAU;AAEtB,8BAAU,MAAM;AACd,QAAI,UAAU;AAAA,EAChB,CAAC;AAED,SAAO,IAAI;AACb;","names":["import_slate"]}