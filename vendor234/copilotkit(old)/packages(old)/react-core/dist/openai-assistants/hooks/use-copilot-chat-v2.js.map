{"version":3,"sources":["../../../src/openai-assistants/hooks/use-copilot-chat-v2.ts","../../../src/openai-assistants/utils/process-message-stream.ts","../../../src/context/copilot-context.tsx","../../../src/components/copilot-provider/copilotkit.tsx"],"sourcesContent":["import { useContext, useMemo, useState } from \"react\";\nimport { processMessageStream } from \"../utils\";\nimport { Message, parseStreamPart } from \"@copilotkit/shared\";\nimport { CopilotContext } from \"../../context\";\nimport { defaultCopilotContextCategories } from \"../../components\";\n\nexport type AssistantStatus = \"in_progress\" | \"awaiting_message\";\n\nexport interface RequestForwardingOptions {\n  /**\n   * The credentials mode to be used for the fetch request.\n   * Possible values are: 'omit', 'same-origin', 'include'.\n   * Defaults to 'same-origin'.\n   */\n  credentials?: RequestCredentials;\n  /**\n   * HTTP headers to be sent with the API request.\n   */\n  headers?: Record<string, string> | Headers;\n  /**\n   * Extra body object to be sent with the API request.\n   * @example\n   * Send a `sessionId` to the API along with the messages.\n   * ```js\n   * useChat({\n   *   body: {\n   *     sessionId: '123',\n   *   }\n   * })\n   * ```\n   */\n  body?: object;\n}\nexport interface UseCopilotChatOptionsV2 extends RequestForwardingOptions {\n  makeSystemMessage?: (contextString: string) => string;\n  threadId?: string | undefined;\n}\n\nexport interface UseCopilotChatV2Result {\n  messages: Message[];\n  input: string;\n  handleInputChange: (e: any) => void;\n  submitMessage: (e: any) => Promise<void>;\n  status: AssistantStatus;\n  error: unknown;\n}\n\nexport function useCopilotChatV2(options: UseCopilotChatOptionsV2): UseCopilotChatV2Result {\n  const {\n    getContextString,\n    getChatCompletionFunctionDescriptions,\n    getFunctionCallHandler,\n    copilotApiConfig,\n  } = useContext(CopilotContext);\n\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [input, setInput] = useState(\"\");\n  const [threadId, setThreadId] = useState<string | undefined>(undefined);\n  const [status, setStatus] = useState<AssistantStatus>(\"awaiting_message\");\n  const [error, setError] = useState<unknown | undefined>(undefined);\n\n  const systemMessage: Message = useMemo(() => {\n    const systemMessageMaker = options.makeSystemMessage || defaultSystemMessage;\n    const contextString = getContextString([], defaultCopilotContextCategories); // TODO: make the context categories configurable\n\n    return {\n      id: \"system\",\n      content: systemMessageMaker(contextString),\n      role: \"system\",\n    };\n  }, [getContextString, options.makeSystemMessage]);\n\n  const handleInputChange = (e: any) => {\n    setInput(e.target.value);\n  };\n\n  const submitMessage = async (e: any) => {\n    e.preventDefault();\n\n    if (input === \"\") {\n      return;\n    }\n\n    setStatus(\"in_progress\");\n\n    setMessages((messages) => [...messages, { id: \"\", role: \"user\", content: input }]);\n\n    setInput(\"\");\n\n    const apiUrl = copilotApiConfig.chatApiEndpointV2;\n\n    const functions = getChatCompletionFunctionDescriptions();\n\n    const result = await fetch(apiUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...copilotApiConfig.headers,\n        ...options.headers,\n      },\n      body: JSON.stringify({\n        // always use user-provided threadId when available:\n        threadId: options.threadId ?? threadId ?? null,\n        message: input,\n        ...(functions.length > 0 && { functions: functions }),\n        ...copilotApiConfig.body,\n        ...options.body,\n      }),\n    });\n\n    if (result.body == null) {\n      throw new Error(\"The response body is empty.\");\n    }\n\n    await processMessageStream(result.body.getReader(), (message: string) => {\n      try {\n        const { type, value } = parseStreamPart(message);\n\n        switch (type) {\n          case \"assistant_message\": {\n            // append message:\n            setMessages((messages) => [\n              ...messages,\n              {\n                id: value.id,\n                role: value.role,\n                content: value.content[0].text.value,\n              },\n            ]);\n            break;\n          }\n\n          case \"assistant_control_data\": {\n            setThreadId(value.threadId);\n\n            // set id of last message:\n            setMessages((messages) => {\n              const lastMessage = messages[messages.length - 1];\n              lastMessage.id = value.messageId;\n              return [...messages.slice(0, messages.length - 1), lastMessage];\n            });\n\n            break;\n          }\n\n          case \"error\": {\n            setError(value);\n            break;\n          }\n        }\n      } catch (error) {\n        setError(error);\n      }\n    });\n\n    setStatus(\"awaiting_message\");\n  };\n\n  return {\n    messages,\n    input,\n    handleInputChange,\n    submitMessage,\n    status,\n    error,\n  };\n}\n\nexport function defaultSystemMessage(contextString: string): string {\n  return `\nPlease act as an efficient, competent, conscientious, and industrious professional assistant.\n\nHelp the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.\nAlways be polite and respectful, and prefer brevity over verbosity.\n\nThe user has provided you with the following context:\n\\`\\`\\`\n${contextString}\n\\`\\`\\`\n\nThey have also provided you with functions you can call to initiate actions on their behalf, or functions you can call to receive more information.\n\nPlease assist them as best you can.\n\nYou can ask them for clarifying questions if needed, but don't be annoying about it. If you can reasonably 'fill in the blanks' yourself, do so.\n\nIf you would like to call a function, call it without saying anything else.\n`;\n}\n","export async function processMessageStream(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n  processMessage: (message: string) => void | Promise<void>,\n) {\n  const decoder = new TextDecoder();\n  let buffer = \"\";\n  while (true) {\n    const { done, value } = await reader.read();\n\n    if (done) {\n      if (buffer.length > 0) {\n        processMessage(buffer);\n      }\n      break;\n    }\n\n    buffer += decoder.decode(value, { stream: true });\n\n    let endIndex: number;\n    while ((endIndex = buffer.indexOf(\"\\n\")) !== -1) {\n      processMessage(buffer.substring(0, endIndex).trim());\n      buffer = buffer.substring(endIndex + 1); // Remove the processed instruction + delimiter\n    }\n  }\n}\n","\"use client\";\n\nimport { FunctionCallHandler, AnnotatedFunction, ToolDefinition } from \"@copilotkit/shared\";\nimport React from \"react\";\nimport { TreeNodeId } from \"../hooks/use-tree\";\nimport { DocumentPointer } from \"../types\";\n\n/**\n * Interface for the configuration of the Copilot API.\n */\nexport interface CopilotApiConfig {\n  /**\n   * The endpoint for the chat API.\n   */\n  chatApiEndpoint: string;\n\n  /**\n   * The endpoint for the chat API v2.\n   */\n  chatApiEndpointV2: string;\n\n  /**\n   * additional headers to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'Authorization': 'Bearer your_token_here'\n   * }\n   * ```\n   */\n  headers: Record<string, string>;\n\n  /**\n   * Additional body params to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'message': 'Hello, world!'\n   * }\n   * ```\n   */\n  body: Record<string, any>;\n\n  /**\n   * Backend only props that will be combined to body params to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'user_id': 'user_id'\n   * }\n   * ```\n   */\n  backendOnlyProps?: Record<string, any>;\n}\n\nexport interface CopilotContextParams {\n  // function-calling\n  entryPoints: Record<string, AnnotatedFunction<any[]>>;\n  setEntryPoint: (id: string, entryPoint: AnnotatedFunction<any[]>) => void;\n  removeEntryPoint: (id: string) => void;\n  getChatCompletionFunctionDescriptions: (\n    customEntryPoints?: Record<string, AnnotatedFunction<any[]>>,\n  ) => ToolDefinition[];\n  getFunctionCallHandler: (\n    customEntryPoints?: Record<string, AnnotatedFunction<any[]>>,\n  ) => FunctionCallHandler;\n\n  // text context\n  addContext: (context: string, parentId?: string, categories?: string[]) => TreeNodeId;\n  removeContext: (id: TreeNodeId) => void;\n  getContextString: (documents: DocumentPointer[], categories: string[]) => string;\n\n  // document context\n  addDocumentContext: (documentPointer: DocumentPointer, categories?: string[]) => TreeNodeId;\n  removeDocumentContext: (documentId: string) => void;\n  getDocumentsContext: (categories: string[]) => DocumentPointer[];\n\n  // api endpoints\n  copilotApiConfig: CopilotApiConfig;\n}\n\nconst emptyCopilotContext: CopilotContextParams = {\n  entryPoints: {},\n  setEntryPoint: () => {},\n  removeEntryPoint: () => {},\n  getChatCompletionFunctionDescriptions: () => returnAndThrowInDebug([]),\n  getFunctionCallHandler: () => returnAndThrowInDebug(async () => {}),\n\n  getContextString: (documents: DocumentPointer[], categories: string[]) =>\n    returnAndThrowInDebug(\"\"),\n  addContext: () => \"\",\n  removeContext: () => {},\n\n  getDocumentsContext: (categories: string[]) => returnAndThrowInDebug([]),\n  addDocumentContext: () => returnAndThrowInDebug(\"\"),\n  removeDocumentContext: () => {},\n\n  copilotApiConfig: new (class implements CopilotApiConfig {\n    get chatApiEndpoint(): string {\n      throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n    }\n    get chatApiEndpointV2(): string {\n      throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n    }\n    get headers(): Record<string, string> {\n      return {};\n    }\n    get body(): Record<string, any> {\n      return {};\n    }\n  })(),\n};\n\nexport const CopilotContext = React.createContext<CopilotContextParams>(emptyCopilotContext);\n\nexport function useCopilotContext(): CopilotContextParams {\n  return React.useContext(CopilotContext);\n}\n\nfunction returnAndThrowInDebug<T>(value: T): T {\n  throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n  return value;\n}\n","\"use client\";\n\nimport { FunctionDefinition } from \"@copilotkit/shared\";\nimport { useCallback, useState } from \"react\";\nimport { CopilotContext, CopilotApiConfig } from \"../../context/copilot-context\";\nimport useTree from \"../../hooks/use-tree\";\nimport { DocumentPointer } from \"../../types\";\nimport {\n  FunctionCallHandler,\n  AnnotatedFunction,\n  annotatedFunctionToChatCompletionFunction,\n} from \"@copilotkit/shared\";\nimport useFlatCategoryStore from \"../../hooks/use-flat-category-store\";\nimport { StandardCopilotApiConfig } from \"./standard-copilot-api-config\";\nimport { CopilotKitProps } from \"./copilotkit-props\";\nimport { ToolDefinition } from \"@copilotkit/shared\";\n\n/**\n * The CopilotKit component.\n * This component provides the Copilot context to its children.\n * It can be configured either with a chat API endpoint or a CopilotApiConfig.\n *\n * NOTE: The backend can use OpenAI, or you can bring your own LLM.\n * For examples of the backend api implementation, see `examples/next-openai` usage (under `src/api/copilotkit`),\n * or read the documentation at https://docs.copilotkit.ai\n * In particular, Getting-Started > Quickstart-Backend: https://docs.copilotkit.ai/getting-started/quickstart-backend\n *\n * Example usage:\n * ```\n * <CopilotKit url=\"https://your.copilotkit.api\">\n *    <App />\n * </CopilotKit>\n * ```\n *\n * or\n *\n * ```\n * const copilotApiConfig = new StandardCopilotApiConfig(\n *  \"https://your.copilotkit.api/v1\",\n *  \"https://your.copilotkit.api/v2\",\n *  {},\n *  {}\n *  );\n *\n * // ...\n *\n * <CopilotKit chatApiConfig={copilotApiConfig}>\n *    <App />\n * </CopilotKit>\n * ```\n *\n * @param props - The props for the component.\n * @returns The CopilotKit component.\n */\nexport function CopilotKit({ children, ...props }: CopilotKitProps) {\n  // Compute all the functions and properties that we need to pass\n  // to the CopilotContext.\n\n  const [entryPoints, setEntryPoints] = useState<Record<string, AnnotatedFunction<any[]>>>({});\n\n  const { addElement, removeElement, printTree } = useTree();\n\n  const {\n    addElement: addDocument,\n    removeElement: removeDocument,\n    allElements: allDocuments,\n  } = useFlatCategoryStore<DocumentPointer>();\n\n  const setEntryPoint = useCallback((id: string, entryPoint: AnnotatedFunction<any[]>) => {\n    setEntryPoints((prevPoints) => {\n      return {\n        ...prevPoints,\n        [id]: entryPoint,\n      };\n    });\n  }, []);\n\n  const removeEntryPoint = useCallback((id: string) => {\n    setEntryPoints((prevPoints) => {\n      const newPoints = { ...prevPoints };\n      delete newPoints[id];\n      return newPoints;\n    });\n  }, []);\n\n  const getContextString = useCallback(\n    (documents: DocumentPointer[], categories: string[]) => {\n      const documentsString = documents\n        .map((document) => {\n          return `${document.name} (${document.sourceApplication}):\\n${document.getContents()}`;\n        })\n        .join(\"\\n\\n\");\n\n      const nonDocumentStrings = printTree(categories);\n\n      return `${documentsString}\\n\\n${nonDocumentStrings}`;\n    },\n    [printTree],\n  );\n\n  const addContext = useCallback(\n    (\n      context: string,\n      parentId?: string,\n      categories: string[] = defaultCopilotContextCategories,\n    ) => {\n      return addElement(context, categories, parentId);\n    },\n    [addElement],\n  );\n\n  const removeContext = useCallback(\n    (id: string) => {\n      removeElement(id);\n    },\n    [removeElement],\n  );\n\n  const getChatCompletionFunctionDescriptions = useCallback(\n    (customEntryPoints?: Record<string, AnnotatedFunction<any[]>>) => {\n      return entryPointsToChatCompletionFunctions(Object.values(customEntryPoints || entryPoints));\n    },\n    [entryPoints],\n  );\n\n  const getFunctionCallHandler = useCallback(\n    (customEntryPoints?: Record<string, AnnotatedFunction<any[]>>) => {\n      return entryPointsToFunctionCallHandler(Object.values(customEntryPoints || entryPoints));\n    },\n    [entryPoints],\n  );\n\n  const getDocumentsContext = useCallback(\n    (categories: string[]) => {\n      return allDocuments(categories);\n    },\n    [allDocuments],\n  );\n\n  const addDocumentContext = useCallback(\n    (documentPointer: DocumentPointer, categories: string[] = defaultCopilotContextCategories) => {\n      return addDocument(documentPointer, categories);\n    },\n    [addDocument],\n  );\n\n  const removeDocumentContext = useCallback(\n    (documentId: string) => {\n      removeDocument(documentId);\n    },\n    [removeDocument],\n  );\n\n  // get the appropriate CopilotApiConfig from the props\n  const copilotApiConfig: CopilotApiConfig = new StandardCopilotApiConfig(\n    props.url,\n    `${props.url}/v2`,\n    props.headers || {},\n    {\n      ...props.body,\n      ...props.backendOnlyProps,\n    },\n  );\n\n  return (\n    <CopilotContext.Provider\n      value={{\n        entryPoints,\n        getChatCompletionFunctionDescriptions,\n        getFunctionCallHandler,\n        setEntryPoint,\n        removeEntryPoint,\n        getContextString,\n        addContext,\n        removeContext,\n        getDocumentsContext,\n        addDocumentContext,\n        removeDocumentContext,\n        copilotApiConfig: copilotApiConfig,\n      }}\n    >\n      {children}\n    </CopilotContext.Provider>\n  );\n}\n\nexport const defaultCopilotContextCategories = [\"global\"];\n\nfunction entryPointsToFunctionCallHandler(\n  entryPoints: AnnotatedFunction<any[]>[],\n): FunctionCallHandler {\n  return async (chatMessages, functionCall) => {\n    let entrypointsByFunctionName: Record<string, AnnotatedFunction<any[]>> = {};\n    for (let entryPoint of entryPoints) {\n      entrypointsByFunctionName[entryPoint.name] = entryPoint;\n    }\n\n    const entryPointFunction = entrypointsByFunctionName[functionCall.name || \"\"];\n    if (entryPointFunction) {\n      let functionCallArguments: Record<string, any>[] = [];\n      if (functionCall.arguments) {\n        functionCallArguments = JSON.parse(functionCall.arguments);\n      }\n\n      const paramsInCorrectOrder: any[] = [];\n      for (let arg of entryPointFunction.argumentAnnotations) {\n        paramsInCorrectOrder.push(\n          functionCallArguments[arg.name as keyof typeof functionCallArguments],\n        );\n      }\n\n      await entryPointFunction.implementation(...paramsInCorrectOrder);\n\n      // commented out becasue for now we don't want to return anything\n      // const result = await entryPointFunction.implementation(\n      //   ...parsedFunctionCallArguments\n      // );\n      // const functionResponse: ChatRequest = {\n      //   messages: [\n      //     ...chatMessages,\n      //     {\n      //       id: nanoid(),\n      //       name: functionCall.name,\n      //       role: 'function' as const,\n      //       content: JSON.stringify(result),\n      //     },\n      //   ],\n      // };\n\n      // return functionResponse;\n    }\n  };\n}\n\nfunction entryPointsToChatCompletionFunctions(\n  entryPoints: AnnotatedFunction<any[]>[],\n): ToolDefinition[] {\n  return entryPoints.map(annotatedFunctionToChatCompletionFunction);\n}\n"],"mappings":"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","names":["import_react","import_shared","React","import_react","messages","error"]}