{"version":3,"sources":["../src/index.tsx","../src/components/copilot-provider/copilotkit.tsx","../src/context/copilot-context.tsx","../src/hooks/use-tree.ts","../src/hooks/use-flat-category-store.ts","../src/components/copilot-provider/standard-copilot-api-config.tsx","../src/hooks/use-copilot-chat.ts","../src/hooks/use-chat.ts","../src/utils/fetch-chat-completion.ts","../src/hooks/use-make-copilot-actionable.ts","../src/hooks/use-make-copilot-readable.ts","../src/hooks/use-make-copilot-document-readable.ts","../src/openai-assistants/hooks/use-copilot-chat-v2.ts","../src/openai-assistants/utils/process-message-stream.ts","../src/lib/copilot-task.ts"],"sourcesContent":["export * from \"./components\";\nexport * from \"./context\";\nexport * from \"./hooks\";\nexport * from \"./types\";\nexport * from \"./openai-assistants\";\nexport * from \"./lib\";\nexport {\n  type FetchChatCompletionParams,\n  fetchChatCompletion,\n  fetchAndDecodeChatCompletion,\n  fetchAndDecodeChatCompletionAsText,\n} from \"./utils/fetch-chat-completion\";\n","\"use client\";\n\nimport { FunctionDefinition } from \"@copilotkit/shared\";\nimport { useCallback, useState } from \"react\";\nimport { CopilotContext, CopilotApiConfig } from \"../../context/copilot-context\";\nimport useTree from \"../../hooks/use-tree\";\nimport { DocumentPointer } from \"../../types\";\nimport {\n  FunctionCallHandler,\n  AnnotatedFunction,\n  annotatedFunctionToChatCompletionFunction,\n} from \"@copilotkit/shared\";\nimport useFlatCategoryStore from \"../../hooks/use-flat-category-store\";\nimport { StandardCopilotApiConfig } from \"./standard-copilot-api-config\";\nimport { CopilotKitProps } from \"./copilotkit-props\";\nimport { ToolDefinition } from \"@copilotkit/shared\";\n\n/**\n * The CopilotKit component.\n * This component provides the Copilot context to its children.\n * It can be configured either with a chat API endpoint or a CopilotApiConfig.\n *\n * NOTE: The backend can use OpenAI, or you can bring your own LLM.\n * For examples of the backend api implementation, see `examples/next-openai` usage (under `src/api/copilotkit`),\n * or read the documentation at https://docs.copilotkit.ai\n * In particular, Getting-Started > Quickstart-Backend: https://docs.copilotkit.ai/getting-started/quickstart-backend\n *\n * Example usage:\n * ```\n * <CopilotKit url=\"https://your.copilotkit.api\">\n *    <App />\n * </CopilotKit>\n * ```\n *\n * or\n *\n * ```\n * const copilotApiConfig = new StandardCopilotApiConfig(\n *  \"https://your.copilotkit.api/v1\",\n *  \"https://your.copilotkit.api/v2\",\n *  {},\n *  {}\n *  );\n *\n * // ...\n *\n * <CopilotKit chatApiConfig={copilotApiConfig}>\n *    <App />\n * </CopilotKit>\n * ```\n *\n * @param props - The props for the component.\n * @returns The CopilotKit component.\n */\nexport function CopilotKit({ children, ...props }: CopilotKitProps) {\n  // Compute all the functions and properties that we need to pass\n  // to the CopilotContext.\n\n  const [entryPoints, setEntryPoints] = useState<Record<string, AnnotatedFunction<any[]>>>({});\n\n  const { addElement, removeElement, printTree } = useTree();\n\n  const {\n    addElement: addDocument,\n    removeElement: removeDocument,\n    allElements: allDocuments,\n  } = useFlatCategoryStore<DocumentPointer>();\n\n  const setEntryPoint = useCallback((id: string, entryPoint: AnnotatedFunction<any[]>) => {\n    setEntryPoints((prevPoints) => {\n      return {\n        ...prevPoints,\n        [id]: entryPoint,\n      };\n    });\n  }, []);\n\n  const removeEntryPoint = useCallback((id: string) => {\n    setEntryPoints((prevPoints) => {\n      const newPoints = { ...prevPoints };\n      delete newPoints[id];\n      return newPoints;\n    });\n  }, []);\n\n  const getContextString = useCallback(\n    (documents: DocumentPointer[], categories: string[]) => {\n      const documentsString = documents\n        .map((document) => {\n          return `${document.name} (${document.sourceApplication}):\\n${document.getContents()}`;\n        })\n        .join(\"\\n\\n\");\n\n      const nonDocumentStrings = printTree(categories);\n\n      return `${documentsString}\\n\\n${nonDocumentStrings}`;\n    },\n    [printTree],\n  );\n\n  const addContext = useCallback(\n    (\n      context: string,\n      parentId?: string,\n      categories: string[] = defaultCopilotContextCategories,\n    ) => {\n      return addElement(context, categories, parentId);\n    },\n    [addElement],\n  );\n\n  const removeContext = useCallback(\n    (id: string) => {\n      removeElement(id);\n    },\n    [removeElement],\n  );\n\n  const getChatCompletionFunctionDescriptions = useCallback(\n    (customEntryPoints?: Record<string, AnnotatedFunction<any[]>>) => {\n      return entryPointsToChatCompletionFunctions(Object.values(customEntryPoints || entryPoints));\n    },\n    [entryPoints],\n  );\n\n  const getFunctionCallHandler = useCallback(\n    (customEntryPoints?: Record<string, AnnotatedFunction<any[]>>) => {\n      return entryPointsToFunctionCallHandler(Object.values(customEntryPoints || entryPoints));\n    },\n    [entryPoints],\n  );\n\n  const getDocumentsContext = useCallback(\n    (categories: string[]) => {\n      return allDocuments(categories);\n    },\n    [allDocuments],\n  );\n\n  const addDocumentContext = useCallback(\n    (documentPointer: DocumentPointer, categories: string[] = defaultCopilotContextCategories) => {\n      return addDocument(documentPointer, categories);\n    },\n    [addDocument],\n  );\n\n  const removeDocumentContext = useCallback(\n    (documentId: string) => {\n      removeDocument(documentId);\n    },\n    [removeDocument],\n  );\n\n  // get the appropriate CopilotApiConfig from the props\n  const copilotApiConfig: CopilotApiConfig = new StandardCopilotApiConfig(\n    props.url,\n    `${props.url}/v2`,\n    props.headers || {},\n    {\n      ...props.body,\n      ...props.backendOnlyProps,\n    },\n  );\n\n  return (\n    <CopilotContext.Provider\n      value={{\n        entryPoints,\n        getChatCompletionFunctionDescriptions,\n        getFunctionCallHandler,\n        setEntryPoint,\n        removeEntryPoint,\n        getContextString,\n        addContext,\n        removeContext,\n        getDocumentsContext,\n        addDocumentContext,\n        removeDocumentContext,\n        copilotApiConfig: copilotApiConfig,\n      }}\n    >\n      {children}\n    </CopilotContext.Provider>\n  );\n}\n\nexport const defaultCopilotContextCategories = [\"global\"];\n\nfunction entryPointsToFunctionCallHandler(\n  entryPoints: AnnotatedFunction<any[]>[],\n): FunctionCallHandler {\n  return async (chatMessages, functionCall) => {\n    let entrypointsByFunctionName: Record<string, AnnotatedFunction<any[]>> = {};\n    for (let entryPoint of entryPoints) {\n      entrypointsByFunctionName[entryPoint.name] = entryPoint;\n    }\n\n    const entryPointFunction = entrypointsByFunctionName[functionCall.name || \"\"];\n    if (entryPointFunction) {\n      let functionCallArguments: Record<string, any>[] = [];\n      if (functionCall.arguments) {\n        functionCallArguments = JSON.parse(functionCall.arguments);\n      }\n\n      const paramsInCorrectOrder: any[] = [];\n      for (let arg of entryPointFunction.argumentAnnotations) {\n        paramsInCorrectOrder.push(\n          functionCallArguments[arg.name as keyof typeof functionCallArguments],\n        );\n      }\n\n      await entryPointFunction.implementation(...paramsInCorrectOrder);\n\n      // commented out becasue for now we don't want to return anything\n      // const result = await entryPointFunction.implementation(\n      //   ...parsedFunctionCallArguments\n      // );\n      // const functionResponse: ChatRequest = {\n      //   messages: [\n      //     ...chatMessages,\n      //     {\n      //       id: nanoid(),\n      //       name: functionCall.name,\n      //       role: 'function' as const,\n      //       content: JSON.stringify(result),\n      //     },\n      //   ],\n      // };\n\n      // return functionResponse;\n    }\n  };\n}\n\nfunction entryPointsToChatCompletionFunctions(\n  entryPoints: AnnotatedFunction<any[]>[],\n): ToolDefinition[] {\n  return entryPoints.map(annotatedFunctionToChatCompletionFunction);\n}\n","\"use client\";\n\nimport { FunctionCallHandler, AnnotatedFunction, ToolDefinition } from \"@copilotkit/shared\";\nimport React from \"react\";\nimport { TreeNodeId } from \"../hooks/use-tree\";\nimport { DocumentPointer } from \"../types\";\n\n/**\n * Interface for the configuration of the Copilot API.\n */\nexport interface CopilotApiConfig {\n  /**\n   * The endpoint for the chat API.\n   */\n  chatApiEndpoint: string;\n\n  /**\n   * The endpoint for the chat API v2.\n   */\n  chatApiEndpointV2: string;\n\n  /**\n   * additional headers to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'Authorization': 'Bearer your_token_here'\n   * }\n   * ```\n   */\n  headers: Record<string, string>;\n\n  /**\n   * Additional body params to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'message': 'Hello, world!'\n   * }\n   * ```\n   */\n  body: Record<string, any>;\n\n  /**\n   * Backend only props that will be combined to body params to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'user_id': 'user_id'\n   * }\n   * ```\n   */\n  backendOnlyProps?: Record<string, any>;\n}\n\nexport interface CopilotContextParams {\n  // function-calling\n  entryPoints: Record<string, AnnotatedFunction<any[]>>;\n  setEntryPoint: (id: string, entryPoint: AnnotatedFunction<any[]>) => void;\n  removeEntryPoint: (id: string) => void;\n  getChatCompletionFunctionDescriptions: (\n    customEntryPoints?: Record<string, AnnotatedFunction<any[]>>,\n  ) => ToolDefinition[];\n  getFunctionCallHandler: (\n    customEntryPoints?: Record<string, AnnotatedFunction<any[]>>,\n  ) => FunctionCallHandler;\n\n  // text context\n  addContext: (context: string, parentId?: string, categories?: string[]) => TreeNodeId;\n  removeContext: (id: TreeNodeId) => void;\n  getContextString: (documents: DocumentPointer[], categories: string[]) => string;\n\n  // document context\n  addDocumentContext: (documentPointer: DocumentPointer, categories?: string[]) => TreeNodeId;\n  removeDocumentContext: (documentId: string) => void;\n  getDocumentsContext: (categories: string[]) => DocumentPointer[];\n\n  // api endpoints\n  copilotApiConfig: CopilotApiConfig;\n}\n\nconst emptyCopilotContext: CopilotContextParams = {\n  entryPoints: {},\n  setEntryPoint: () => {},\n  removeEntryPoint: () => {},\n  getChatCompletionFunctionDescriptions: () => returnAndThrowInDebug([]),\n  getFunctionCallHandler: () => returnAndThrowInDebug(async () => {}),\n\n  getContextString: (documents: DocumentPointer[], categories: string[]) =>\n    returnAndThrowInDebug(\"\"),\n  addContext: () => \"\",\n  removeContext: () => {},\n\n  getDocumentsContext: (categories: string[]) => returnAndThrowInDebug([]),\n  addDocumentContext: () => returnAndThrowInDebug(\"\"),\n  removeDocumentContext: () => {},\n\n  copilotApiConfig: new (class implements CopilotApiConfig {\n    get chatApiEndpoint(): string {\n      throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n    }\n    get chatApiEndpointV2(): string {\n      throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n    }\n    get headers(): Record<string, string> {\n      return {};\n    }\n    get body(): Record<string, any> {\n      return {};\n    }\n  })(),\n};\n\nexport const CopilotContext = React.createContext<CopilotContextParams>(emptyCopilotContext);\n\nexport function useCopilotContext(): CopilotContextParams {\n  return React.useContext(CopilotContext);\n}\n\nfunction returnAndThrowInDebug<T>(value: T): T {\n  throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n  return value;\n}\n","import { nanoid } from \"nanoid\";\nimport { useCallback, useReducer } from \"react\";\n\nexport type TreeNodeId = string;\n\nexport interface TreeNode {\n  id: TreeNodeId;\n  value: string;\n  children: TreeNode[];\n  parentId?: TreeNodeId;\n  categories: Set<string>;\n}\n\nexport type Tree = TreeNode[];\n\nexport interface UseTreeReturn {\n  tree: Tree;\n  addElement: (value: string, categories: string[], parentId?: TreeNodeId) => TreeNodeId;\n  printTree: (categories: string[]) => string;\n  removeElement: (id: TreeNodeId) => void;\n}\n\nconst findNode = (nodes: Tree, id: TreeNodeId): TreeNode | undefined => {\n  for (const node of nodes) {\n    if (node.id === id) {\n      return node;\n    }\n    const result = findNode(node.children, id);\n    if (result) {\n      return result;\n    }\n  }\n  return undefined;\n};\n\nconst removeNode = (nodes: Tree, id: TreeNodeId): Tree => {\n  return nodes.reduce((result: Tree, node) => {\n    if (node.id !== id) {\n      const newNode = { ...node, children: removeNode(node.children, id) };\n      result.push(newNode);\n    }\n    return result;\n  }, []);\n};\n\nconst addNode = (nodes: Tree, newNode: TreeNode, parentId?: TreeNodeId): Tree => {\n  if (!parentId) {\n    return [...nodes, newNode];\n  }\n  return nodes.map((node) => {\n    if (node.id === parentId) {\n      return { ...node, children: [...node.children, newNode] };\n    } else if (node.children.length) {\n      return { ...node, children: addNode(node.children, newNode, parentId) };\n    }\n    return node;\n  });\n};\n\nconst treeIndentationRepresentation = (index: number, indentLevel: number): string => {\n  if (indentLevel === 0) {\n    return (index + 1).toString();\n  } else if (indentLevel === 1) {\n    return String.fromCharCode(65 + index); // 65 is the ASCII value for 'A'\n  } else if (indentLevel === 2) {\n    return String.fromCharCode(97 + index); // 97 is the ASCII value for 'a'\n  } else {\n    return \"-\";\n  }\n};\n\nconst printNode = (node: TreeNode, prefix = \"\", indentLevel = 0): string => {\n  const indent = \" \".repeat(3).repeat(indentLevel);\n\n  const prefixPlusIndentLength = prefix.length + indent.length;\n  const subsequentLinesPrefix = \" \".repeat(prefixPlusIndentLength);\n\n  const valueLines = node.value.split(\"\\n\");\n\n  const outputFirstLine = `${indent}${prefix}${valueLines[0]}`;\n  const outputSubsequentLines = valueLines\n    .slice(1)\n    .map((line) => `${subsequentLinesPrefix}${line}`)\n    .join(\"\\n\");\n\n  let output = `${outputFirstLine}\\n`;\n  if (outputSubsequentLines) {\n    output += `${outputSubsequentLines}\\n`;\n  }\n\n  const childPrePrefix = \" \".repeat(prefix.length);\n\n  node.children.forEach(\n    (child, index) =>\n      (output += printNode(\n        child,\n        `${childPrePrefix}${treeIndentationRepresentation(index, indentLevel + 1)}. `,\n        indentLevel + 1,\n      )),\n  );\n  return output;\n};\n\n// Action types\ntype Action =\n  | {\n      type: \"ADD_NODE\";\n      value: string;\n      parentId?: string;\n      id: string;\n      categories: string[];\n    }\n  | { type: \"REMOVE_NODE\"; id: string };\n\n// Reducer function\nfunction treeReducer(state: Tree, action: Action): Tree {\n  switch (action.type) {\n    case \"ADD_NODE\": {\n      const { value, parentId, id: newNodeId } = action;\n      const newNode: TreeNode = {\n        id: newNodeId,\n        value,\n        children: [],\n        categories: new Set(action.categories),\n      };\n\n      try {\n        return addNode(state, newNode, parentId);\n      } catch (error) {\n        console.error(`Error while adding node with id ${newNodeId}: ${error}`);\n        return state;\n      }\n    }\n    case \"REMOVE_NODE\":\n      return removeNode(state, action.id);\n    default:\n      return state;\n  }\n}\n\n// useTree hook\nconst useTree = (): UseTreeReturn => {\n  const [tree, dispatch] = useReducer(treeReducer, []);\n\n  const addElement = useCallback(\n    (value: string, categories: string[], parentId?: string): TreeNodeId => {\n      const newNodeId = nanoid(); // Generate new ID outside of dispatch\n      dispatch({\n        type: \"ADD_NODE\",\n        value,\n        parentId,\n        id: newNodeId,\n        categories: categories,\n      });\n      return newNodeId; // Return the new ID\n    },\n    [],\n  );\n\n  const removeElement = useCallback((id: TreeNodeId): void => {\n    dispatch({ type: \"REMOVE_NODE\", id });\n  }, []);\n\n  const printTree = useCallback(\n    (categories: string[]): string => {\n      const categoriesSet = new Set(categories);\n\n      let output = \"\";\n      tree.forEach((node, index) => {\n        // if the node does not have any of the desired categories, continue to the next node\n        if (!setsHaveIntersection(categoriesSet, node.categories)) {\n          return;\n        }\n\n        // add a new line before each node except the first one\n        if (index !== 0) {\n          output += \"\\n\";\n        }\n\n        output += printNode(node, `${treeIndentationRepresentation(index, 0)}. `);\n      });\n      return output;\n    },\n    [tree],\n  );\n\n  return { tree, addElement, printTree, removeElement };\n};\n\nexport default useTree;\n\nfunction setsHaveIntersection<T>(setA: Set<T>, setB: Set<T>): boolean {\n  const [smallerSet, largerSet] = setA.size <= setB.size ? [setA, setB] : [setB, setA];\n\n  for (let item of smallerSet) {\n    if (largerSet.has(item)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import { nanoid } from \"nanoid\";\nimport { useCallback, useReducer } from \"react\";\n\nexport type FlatCategoryStoreId = string;\n\nexport interface UseFlatCategoryStoreReturn<T> {\n  addElement: (value: T, categories: string[]) => FlatCategoryStoreId;\n  removeElement: (id: FlatCategoryStoreId) => void;\n  allElements: (categories: string[]) => T[];\n}\n\ninterface FlatCategoryStoreElement<T> {\n  id: FlatCategoryStoreId;\n  value: T;\n  categories: Set<string>;\n}\n\nconst useFlatCategoryStore = <T>(): UseFlatCategoryStoreReturn<T> => {\n  const [elements, dispatch] = useReducer<\n    React.Reducer<Map<FlatCategoryStoreId, FlatCategoryStoreElement<T>>, Action<T>>\n  >(flatCategoryStoreReducer, new Map<FlatCategoryStoreId, FlatCategoryStoreElement<T>>());\n\n  const addElement = useCallback((value: T, categories: string[]): FlatCategoryStoreId => {\n    const newId = nanoid();\n    dispatch({\n      type: \"ADD_ELEMENT\",\n      value,\n      id: newId,\n      categories,\n    });\n    return newId;\n  }, []);\n\n  const removeElement = useCallback((id: FlatCategoryStoreId): void => {\n    dispatch({ type: \"REMOVE_ELEMENT\", id });\n  }, []);\n\n  const allElements = useCallback(\n    (categories: string[]): T[] => {\n      const categoriesSet = new Set(categories);\n      const result: T[] = [];\n      elements.forEach((element) => {\n        if (setsHaveIntersection(categoriesSet, element.categories)) {\n          result.push(element.value);\n        }\n      });\n      return result;\n    },\n    [elements],\n  );\n\n  return { addElement, removeElement, allElements };\n};\n\nexport default useFlatCategoryStore;\n\n// Action types\ntype Action<T> =\n  | {\n      type: \"ADD_ELEMENT\";\n      value: T;\n      id: FlatCategoryStoreId;\n      categories: string[];\n    }\n  | { type: \"REMOVE_ELEMENT\"; id: FlatCategoryStoreId };\n\n// Reducer\nfunction flatCategoryStoreReducer<T>(\n  state: Map<FlatCategoryStoreId, FlatCategoryStoreElement<T>>,\n  action: Action<T>,\n): Map<FlatCategoryStoreId, FlatCategoryStoreElement<T>> {\n  switch (action.type) {\n    case \"ADD_ELEMENT\": {\n      const { value, id, categories } = action;\n      const newElement: FlatCategoryStoreElement<T> = {\n        id,\n        value,\n        categories: new Set(categories),\n      };\n      const newState = new Map(state);\n      newState.set(id, newElement);\n      return newState;\n    }\n    case \"REMOVE_ELEMENT\": {\n      const newState = new Map(state);\n      newState.delete(action.id);\n      return newState;\n    }\n    default:\n      return state;\n  }\n}\n\nfunction setsHaveIntersection<T>(setA: Set<T>, setB: Set<T>): boolean {\n  const [smallerSet, largerSet] = setA.size <= setB.size ? [setA, setB] : [setB, setA];\n\n  for (let item of smallerSet) {\n    if (largerSet.has(item)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import { CopilotApiConfig } from \"../../context/copilot-context\";\n\n/**\n * A standard implementation of the CopilotApiConfig interface.\n *\n * Pass in the base URL of the chat API, the headers to be sent with each request, and the body to be sent with each request.\n * The rest of the CopilotApiConfig interface is implemented by default.\n *\n */\n\nexport class StandardCopilotApiConfig implements CopilotApiConfig {\n  chatApiEndpoint: string;\n  chatApiEndpointV2: string;\n  headers: Record<string, string>;\n  body: Record<string, any>;\n\n  constructor(\n    chatApiEndpoint: string,\n    chatApiEndpointV2: string,\n    headers: Record<string, string>,\n    body: Record<string, any>,\n  ) {\n    this.chatApiEndpoint = chatApiEndpoint;\n    this.chatApiEndpointV2 = chatApiEndpointV2;\n    this.headers = headers;\n    this.body = body;\n  }\n}\n","import { useMemo, useContext } from \"react\";\nimport { CopilotContext } from \"../context/copilot-context\";\nimport { Message, ToolDefinition } from \"@copilotkit/shared\";\nimport { SystemMessageFunction } from \"../types\";\nimport { UseChatOptions, useChat } from \"./use-chat\";\nimport { defaultCopilotContextCategories } from \"../components\";\n\nexport interface UseCopilotChatOptions extends UseChatOptions {\n  makeSystemMessage?: SystemMessageFunction;\n  additionalInstructions?: string;\n}\n\nexport interface UseCopilotChatReturn {\n  visibleMessages: Message[];\n  append: (message: Message) => Promise<void>;\n  reload: () => Promise<void>;\n  stop: () => void;\n  isLoading: boolean;\n  input: string;\n  setInput: React.Dispatch<React.SetStateAction<string>>;\n}\n\nexport function useCopilotChat({\n  makeSystemMessage,\n  additionalInstructions,\n  ...options\n}: UseCopilotChatOptions): UseCopilotChatReturn {\n  const {\n    getContextString,\n    getChatCompletionFunctionDescriptions,\n    getFunctionCallHandler,\n    copilotApiConfig,\n  } = useContext(CopilotContext);\n\n  const systemMessage: Message = useMemo(() => {\n    const systemMessageMaker = makeSystemMessage || defaultSystemMessage;\n    const contextString = getContextString([], defaultCopilotContextCategories); // TODO: make the context categories configurable\n\n    return {\n      id: \"system\",\n      content: systemMessageMaker(contextString, additionalInstructions),\n      role: \"system\",\n    };\n  }, [getContextString, makeSystemMessage]);\n\n  const functionDescriptions: ToolDefinition[] = useMemo(() => {\n    return getChatCompletionFunctionDescriptions();\n  }, [getChatCompletionFunctionDescriptions]);\n\n  const { messages, append, reload, stop, isLoading, input, setInput } = useChat({\n    ...options,\n    copilotConfig: copilotApiConfig,\n    id: options.id,\n    initialMessages: [systemMessage].concat(options.initialMessages || []),\n    tools: functionDescriptions,\n    onFunctionCall: getFunctionCallHandler(),\n    headers: { ...options.headers },\n    body: {\n      ...options.body,\n    },\n  });\n\n  const visibleMessages = messages.filter(\n    (message) => message.role === \"user\" || message.role === \"assistant\",\n  );\n\n  return {\n    visibleMessages,\n    append,\n    reload,\n    stop,\n    isLoading,\n    input,\n    setInput,\n  };\n}\n\nexport function defaultSystemMessage(\n  contextString: string,\n  additionalInstructions?: string,\n): string {\n  return (\n    `\nPlease act as an efficient, competent, conscientious, and industrious professional assistant.\n\nHelp the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.\nAlways be polite and respectful, and prefer brevity over verbosity.\n\nThe user has provided you with the following context:\n\\`\\`\\`\n${contextString}\n\\`\\`\\`\n\nThey have also provided you with functions you can call to initiate actions on their behalf, or functions you can call to receive more information.\n\nPlease assist them as best you can.\n\nYou can ask them for clarifying questions if needed, but don't be annoying about it. If you can reasonably 'fill in the blanks' yourself, do so.\n\nIf you would like to call a function, call it without saying anything else.\n` + (additionalInstructions ? `\\n\\n${additionalInstructions}` : \"\")\n  );\n}\n","import { useRef, useState } from \"react\";\nimport { Message, ToolDefinition, FunctionCallHandler, encodeResult } from \"@copilotkit/shared\";\nimport { nanoid } from \"nanoid\";\nimport { fetchAndDecodeChatCompletion } from \"../utils/fetch-chat-completion\";\nimport { CopilotApiConfig } from \"../context\";\n\nexport type UseChatOptions = {\n  /**\n   * The API endpoint that accepts a `{ messages: Message[] }` object and returns\n   * a stream of tokens of the AI chat response. Defaults to `/api/chat`.\n   */\n  api?: string;\n  /**\n   * A unique identifier for the chat. If not provided, a random one will be\n   * generated. When provided, the `useChat` hook with the same `id` will\n   * have shared states across components.\n   */\n  id?: string;\n  /**\n   * System messages of the chat. Defaults to an empty array.\n   */\n  initialMessages?: Message[];\n  /**\n   * Callback function to be called when a function call is received.\n   * If the function returns a `ChatRequest` object, the request will be sent\n   * automatically to the API and will be used to update the chat.\n   */\n  onFunctionCall?: FunctionCallHandler;\n  /**\n   * HTTP headers to be sent with the API request.\n   */\n  headers?: Record<string, string> | Headers;\n  /**\n   * Extra body object to be sent with the API request.\n   * @example\n   * Send a `sessionId` to the API along with the messages.\n   * ```js\n   * useChat({\n   *   body: {\n   *     sessionId: '123',\n   *   }\n   * })\n   * ```\n   */\n  body?: object;\n  /**\n   * Function definitions to be sent to the API.\n   */\n  tools?: ToolDefinition[];\n};\n\nexport type UseChatHelpers = {\n  /** Current messages in the chat */\n  messages: Message[];\n  /**\n   * Append a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   * @param message The message to append\n   */\n  append: (message: Message) => Promise<void>;\n  /**\n   * Reload the last AI chat response for the given chat history. If the last\n   * message isn't from the assistant, it will request the API to generate a\n   * new response.\n   */\n  reload: () => Promise<void>;\n  /**\n   * Abort the current request immediately, keep the generated tokens if any.\n   */\n  stop: () => void;\n  /** The current value of the input */\n  input: string;\n  /** setState-powered method to update the input value */\n  setInput: React.Dispatch<React.SetStateAction<string>>;\n  /** Whether the API request is in progress */\n  isLoading: boolean;\n};\n\nexport type UseChatOptionsWithCopilotConfig = UseChatOptions & {\n  copilotConfig: CopilotApiConfig;\n};\n\nexport function useChat(options: UseChatOptionsWithCopilotConfig): UseChatHelpers {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [input, setInput] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const abortControllerRef = useRef<AbortController>();\n\n  const runChatCompletion = async (messages: Message[]): Promise<Message[]> => {\n    setIsLoading(true);\n\n    const newMessages: Message[] = [\n      {\n        id: nanoid(),\n        createdAt: new Date(),\n        content: \"\",\n        role: \"assistant\",\n      },\n    ];\n    const abortController = new AbortController();\n    abortControllerRef.current = abortController;\n\n    setMessages([...messages, ...newMessages]);\n\n    const messagesWithContext = [...(options.initialMessages || []), ...messages];\n    const response = await fetchAndDecodeChatCompletion({\n      copilotConfig: options.copilotConfig,\n      messages: messagesWithContext,\n      tools: options.tools,\n      headers: options.headers,\n      signal: abortController.signal,\n    });\n\n    if (!response.events) {\n      throw new Error(\"Failed to fetch chat completion\");\n    }\n\n    const reader = response.events.getReader();\n\n    // Whether to feed back the new messages to GPT\n    let feedback = false;\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n\n        if (done) {\n          break;\n        }\n\n        let currentMessage = Object.assign({}, newMessages[newMessages.length - 1]);\n\n        if (value.type === \"content\") {\n          if (currentMessage.function_call || currentMessage.role === \"function\") {\n            // Create a new message if the previous one is a function call or result\n            currentMessage = {\n              id: nanoid(),\n              createdAt: new Date(),\n              content: \"\",\n              role: \"assistant\",\n            };\n            newMessages.push(currentMessage);\n          }\n          currentMessage.content += value.content;\n          newMessages[newMessages.length - 1] = currentMessage;\n          setMessages([...messages, ...newMessages]);\n        } else if (value.type === \"result\") {\n          // When we get a result message, it is already complete\n          currentMessage = {\n            id: nanoid(),\n            role: \"function\",\n            content: value.content,\n            name: value.name,\n          };\n          newMessages.push(currentMessage);\n          setMessages([...messages, ...newMessages]);\n\n          // After receiving a result, feed back the new messages to GPT\n          feedback = true;\n        } else if (value.type === \"function\") {\n          // Create a new message if the previous one is not empty\n          if (\n            currentMessage.content != \"\" ||\n            currentMessage.function_call ||\n            currentMessage.role == \"function\"\n          ) {\n            currentMessage = {\n              id: nanoid(),\n              createdAt: new Date(),\n              content: \"\",\n              role: \"assistant\",\n            };\n            newMessages.push(currentMessage);\n          }\n          currentMessage.function_call = {\n            name: value.name,\n            arguments: JSON.stringify(value.arguments),\n            scope: value.scope,\n          };\n\n          newMessages[newMessages.length - 1] = currentMessage;\n          setMessages([...messages, ...newMessages]);\n\n          // Execute the function call\n          try {\n            if (options.onFunctionCall && value.scope === \"client\") {\n              const result = await options.onFunctionCall(messages, currentMessage.function_call);\n\n              currentMessage = {\n                id: nanoid(),\n                role: \"function\",\n                content: encodeResult(result),\n                name: currentMessage.function_call!.name!,\n              };\n              newMessages.push(currentMessage);\n              setMessages([...messages, ...newMessages]);\n\n              // After a function call, feed back the new messages to GPT\n              feedback = true;\n            }\n          } catch (error) {\n            console.error(\"Failed to execute function call\", error);\n            // TODO: Handle error\n            // this should go to the message itself\n          }\n        }\n      }\n\n      // If we want feedback, run the completion again and return the results\n      if (feedback) {\n        return await runChatCompletion([...messages, ...newMessages]);\n      }\n      // otherwise, return the new messages\n      else {\n        return newMessages.slice();\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const runChatCompletionAndHandleFunctionCall = async (messages: Message[]): Promise<void> => {\n    await runChatCompletion(messages);\n  };\n\n  const append = async (message: Message): Promise<void> => {\n    if (isLoading) {\n      return;\n    }\n    const newMessages = [...messages, message];\n    setMessages(newMessages);\n    return runChatCompletionAndHandleFunctionCall(newMessages);\n  };\n\n  const reload = async (): Promise<void> => {\n    if (isLoading || messages.length === 0) {\n      return;\n    }\n    let newMessages = [...messages];\n    const lastMessage = messages[messages.length - 1];\n\n    if (lastMessage.role === \"assistant\") {\n      newMessages = newMessages.slice(0, -1);\n    }\n    setMessages(newMessages);\n\n    return runChatCompletionAndHandleFunctionCall(newMessages);\n  };\n\n  const stop = (): void => {\n    abortControllerRef.current?.abort();\n  };\n\n  return {\n    messages,\n    append,\n    reload,\n    stop,\n    isLoading,\n    input,\n    setInput,\n  };\n}\n","import {\n  Message,\n  ToolDefinition,\n  ChatCompletionEvent,\n  decodeChatCompletion,\n  parseChatCompletion,\n  decodeChatCompletionAsText,\n  EXCLUDE_FROM_FORWARD_PROPS_KEYS,\n} from \"@copilotkit/shared\";\nimport { CopilotApiConfig } from \"../context\";\n\nexport interface FetchChatCompletionParams {\n  copilotConfig: CopilotApiConfig;\n  model?: string;\n  messages: Message[];\n  tools?: ToolDefinition[];\n  temperature?: number;\n  maxTokens?: number;\n  headers?: Record<string, string> | Headers;\n  body?: object;\n  signal?: AbortSignal;\n}\n\nexport async function fetchChatCompletion({\n  copilotConfig,\n  model,\n  messages,\n  tools,\n  temperature,\n  headers,\n  body,\n  signal,\n}: FetchChatCompletionParams): Promise<Response> {\n  temperature ||= 0.5;\n  tools ||= [];\n\n  // clean up any extra properties from messages\n  const cleanedMessages = messages.map((message) => {\n    const { content, role, name, function_call } = message;\n    return { content, role, name, function_call };\n  });\n\n  const response = await fetch(copilotConfig.chatApiEndpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...copilotConfig.headers,\n      ...(headers ? { ...headers } : {}),\n    },\n    body: JSON.stringify({\n      model,\n      messages: cleanedMessages,\n      stream: true,\n      ...(tools.length ? { tools } : {}),\n      ...(temperature ? { temperature } : {}),\n      ...(tools.length != 0 ? { tool_choice: \"auto\" } : {}),\n      ...copilotConfig.body,\n      ...copilotConfig.backendOnlyProps,\n      ...(Object.keys(copilotConfig[\"body\"] ?? {}).length > 0\n        ? { [EXCLUDE_FROM_FORWARD_PROPS_KEYS]: Object.keys(copilotConfig[\"body\"] ?? {}) }\n        : {}),\n      ...(body ? { ...body } : {}),\n    }),\n    signal,\n  });\n\n  return response;\n}\n\nexport interface DecodedChatCompletionResponse extends Response {\n  events: ReadableStream<ChatCompletionEvent> | null;\n}\n\nexport async function fetchAndDecodeChatCompletion(\n  params: FetchChatCompletionParams,\n): Promise<DecodedChatCompletionResponse> {\n  const response = await fetchChatCompletion(params);\n  if (!response.ok || !response.body) {\n    return { ...response, events: null };\n  }\n  const events = await decodeChatCompletion(parseChatCompletion(response.body));\n  return { ...response, events };\n}\n\nexport interface DecodedChatCompletionResponseAsText extends Response {\n  events: ReadableStream<string> | null;\n}\n\nexport async function fetchAndDecodeChatCompletionAsText(\n  params: FetchChatCompletionParams,\n): Promise<DecodedChatCompletionResponseAsText> {\n  const response = await fetchChatCompletion(params);\n  if (!response.ok || !response.body) {\n    return { ...response, events: null };\n  }\n  const events = await decodeChatCompletionAsText(\n    decodeChatCompletion(parseChatCompletion(response.body)),\n  );\n  return { ...response, events };\n}\n","\"use client\";\n\nimport { useRef, useContext, useEffect, useMemo } from \"react\";\nimport { CopilotContext } from \"../context/copilot-context\";\nimport { AnnotatedFunction } from \"@copilotkit/shared\";\nimport { nanoid } from \"nanoid\";\n\nexport function useMakeCopilotActionable<ActionInput extends any[]>(\n  annotatedFunction: AnnotatedFunction<ActionInput>,\n  dependencies: any[],\n) {\n  const idRef = useRef(nanoid()); // generate a unique id\n  const { setEntryPoint, removeEntryPoint } = useContext(CopilotContext);\n\n  const memoizedAnnotatedFunction: AnnotatedFunction<ActionInput> = useMemo(\n    () => ({\n      name: annotatedFunction.name,\n      description: annotatedFunction.description,\n      argumentAnnotations: annotatedFunction.argumentAnnotations,\n      implementation: annotatedFunction.implementation,\n    }),\n    dependencies,\n  );\n\n  useEffect(() => {\n    setEntryPoint(idRef.current, memoizedAnnotatedFunction as AnnotatedFunction<any[]>);\n\n    return () => {\n      removeEntryPoint(idRef.current);\n    };\n  }, [memoizedAnnotatedFunction, setEntryPoint, removeEntryPoint]);\n}\n","\"use client\";\n\nimport { useContext, useEffect, useRef } from \"react\";\nimport { CopilotContext } from \"../context/copilot-context\";\n\n/**\n * Adds the given information to the Copilot context to make it readable by Copilot.\n * @param information - The information to be added to the Copilot context.\n * @param parentId - The ID of the parent context, if any.\n * @param categories - An array of categories to control which context are visible where. Particularly useful with CopilotTextarea (see `useMakeAutosuggestionFunction`)\n * @returns The ID of the added context.\n */\nexport function useMakeCopilotReadable(\n  information: string,\n  parentId?: string,\n  categories?: string[],\n): string | undefined {\n  const { addContext, removeContext } = useContext(CopilotContext);\n  const idRef = useRef<string>();\n\n  useEffect(() => {\n    const id = addContext(information, parentId, categories);\n    idRef.current = id;\n\n    return () => {\n      removeContext(id);\n    };\n  }, [information, parentId, addContext, removeContext]);\n\n  return idRef.current;\n}\n","\"use client\";\n\nimport { useContext, useEffect, useRef } from \"react\";\nimport { CopilotContext } from \"../context/copilot-context\";\nimport { DocumentPointer } from \"../types\";\n\n/**\n * Makes a document readable by Copilot.\n * @param document The document to make readable.\n * @param categories The categories to associate with the document.\n * @param dependencies The dependencies to use for the effect.\n * @returns The id of the document.\n */\nexport function useMakeCopilotDocumentReadable(\n  document: DocumentPointer,\n  categories?: string[],\n  dependencies: any[] = [],\n): string | undefined {\n  const { addDocumentContext, removeDocumentContext } = useContext(CopilotContext);\n  const idRef = useRef<string>();\n\n  useEffect(() => {\n    const id = addDocumentContext(document, categories);\n    idRef.current = id;\n\n    return () => {\n      removeDocumentContext(id);\n    };\n  }, [addDocumentContext, removeDocumentContext, ...dependencies]);\n\n  return idRef.current;\n}\n","import { useContext, useMemo, useState } from \"react\";\nimport { processMessageStream } from \"../utils\";\nimport { Message, parseStreamPart } from \"@copilotkit/shared\";\nimport { CopilotContext } from \"../../context\";\nimport { defaultCopilotContextCategories } from \"../../components\";\n\nexport type AssistantStatus = \"in_progress\" | \"awaiting_message\";\n\nexport interface RequestForwardingOptions {\n  /**\n   * The credentials mode to be used for the fetch request.\n   * Possible values are: 'omit', 'same-origin', 'include'.\n   * Defaults to 'same-origin'.\n   */\n  credentials?: RequestCredentials;\n  /**\n   * HTTP headers to be sent with the API request.\n   */\n  headers?: Record<string, string> | Headers;\n  /**\n   * Extra body object to be sent with the API request.\n   * @example\n   * Send a `sessionId` to the API along with the messages.\n   * ```js\n   * useChat({\n   *   body: {\n   *     sessionId: '123',\n   *   }\n   * })\n   * ```\n   */\n  body?: object;\n}\nexport interface UseCopilotChatOptionsV2 extends RequestForwardingOptions {\n  makeSystemMessage?: (contextString: string) => string;\n  threadId?: string | undefined;\n}\n\nexport interface UseCopilotChatV2Result {\n  messages: Message[];\n  input: string;\n  handleInputChange: (e: any) => void;\n  submitMessage: (e: any) => Promise<void>;\n  status: AssistantStatus;\n  error: unknown;\n}\n\nexport function useCopilotChatV2(options: UseCopilotChatOptionsV2): UseCopilotChatV2Result {\n  const {\n    getContextString,\n    getChatCompletionFunctionDescriptions,\n    getFunctionCallHandler,\n    copilotApiConfig,\n  } = useContext(CopilotContext);\n\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [input, setInput] = useState(\"\");\n  const [threadId, setThreadId] = useState<string | undefined>(undefined);\n  const [status, setStatus] = useState<AssistantStatus>(\"awaiting_message\");\n  const [error, setError] = useState<unknown | undefined>(undefined);\n\n  const systemMessage: Message = useMemo(() => {\n    const systemMessageMaker = options.makeSystemMessage || defaultSystemMessage;\n    const contextString = getContextString([], defaultCopilotContextCategories); // TODO: make the context categories configurable\n\n    return {\n      id: \"system\",\n      content: systemMessageMaker(contextString),\n      role: \"system\",\n    };\n  }, [getContextString, options.makeSystemMessage]);\n\n  const handleInputChange = (e: any) => {\n    setInput(e.target.value);\n  };\n\n  const submitMessage = async (e: any) => {\n    e.preventDefault();\n\n    if (input === \"\") {\n      return;\n    }\n\n    setStatus(\"in_progress\");\n\n    setMessages((messages) => [...messages, { id: \"\", role: \"user\", content: input }]);\n\n    setInput(\"\");\n\n    const apiUrl = copilotApiConfig.chatApiEndpointV2;\n\n    const functions = getChatCompletionFunctionDescriptions();\n\n    const result = await fetch(apiUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...copilotApiConfig.headers,\n        ...options.headers,\n      },\n      body: JSON.stringify({\n        // always use user-provided threadId when available:\n        threadId: options.threadId ?? threadId ?? null,\n        message: input,\n        ...(functions.length > 0 && { functions: functions }),\n        ...copilotApiConfig.body,\n        ...options.body,\n      }),\n    });\n\n    if (result.body == null) {\n      throw new Error(\"The response body is empty.\");\n    }\n\n    await processMessageStream(result.body.getReader(), (message: string) => {\n      try {\n        const { type, value } = parseStreamPart(message);\n\n        switch (type) {\n          case \"assistant_message\": {\n            // append message:\n            setMessages((messages) => [\n              ...messages,\n              {\n                id: value.id,\n                role: value.role,\n                content: value.content[0].text.value,\n              },\n            ]);\n            break;\n          }\n\n          case \"assistant_control_data\": {\n            setThreadId(value.threadId);\n\n            // set id of last message:\n            setMessages((messages) => {\n              const lastMessage = messages[messages.length - 1];\n              lastMessage.id = value.messageId;\n              return [...messages.slice(0, messages.length - 1), lastMessage];\n            });\n\n            break;\n          }\n\n          case \"error\": {\n            setError(value);\n            break;\n          }\n        }\n      } catch (error) {\n        setError(error);\n      }\n    });\n\n    setStatus(\"awaiting_message\");\n  };\n\n  return {\n    messages,\n    input,\n    handleInputChange,\n    submitMessage,\n    status,\n    error,\n  };\n}\n\nexport function defaultSystemMessage(contextString: string): string {\n  return `\nPlease act as an efficient, competent, conscientious, and industrious professional assistant.\n\nHelp the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.\nAlways be polite and respectful, and prefer brevity over verbosity.\n\nThe user has provided you with the following context:\n\\`\\`\\`\n${contextString}\n\\`\\`\\`\n\nThey have also provided you with functions you can call to initiate actions on their behalf, or functions you can call to receive more information.\n\nPlease assist them as best you can.\n\nYou can ask them for clarifying questions if needed, but don't be annoying about it. If you can reasonably 'fill in the blanks' yourself, do so.\n\nIf you would like to call a function, call it without saying anything else.\n`;\n}\n","export async function processMessageStream(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n  processMessage: (message: string) => void | Promise<void>,\n) {\n  const decoder = new TextDecoder();\n  let buffer = \"\";\n  while (true) {\n    const { done, value } = await reader.read();\n\n    if (done) {\n      if (buffer.length > 0) {\n        processMessage(buffer);\n      }\n      break;\n    }\n\n    buffer += decoder.decode(value, { stream: true });\n\n    let endIndex: number;\n    while ((endIndex = buffer.indexOf(\"\\n\")) !== -1) {\n      processMessage(buffer.substring(0, endIndex).trim());\n      buffer = buffer.substring(endIndex + 1); // Remove the processed instruction + delimiter\n    }\n  }\n}\n","import { AnnotatedFunction, FunctionCall, Message } from \"@copilotkit/shared\";\nimport { CopilotContextParams } from \"../context\";\nimport { defaultCopilotContextCategories } from \"../components\";\nimport { fetchAndDecodeChatCompletion } from \"../utils/fetch-chat-completion\";\n\nexport interface CopilotTaskConfig {\n  /**\n   * The instructions to be given to the assistant.\n   */\n  instructions: string;\n  /**\n   * Action definitions to be sent to the API.\n   */\n  actions?: AnnotatedFunction<any[]>[];\n  /**\n   * Whether to include the copilot readable context in the task.\n   */\n  includeCopilotReadable?: boolean;\n\n  /**\n   * Whether to include actions defined via useMakeCopilotActionable in the task.\n   */\n  includeCopilotActionable?: boolean;\n}\n\nexport class CopilotTask<T = any> {\n  private instructions: string;\n  private functions: AnnotatedFunction<any[]>[];\n  private includeCopilotReadable: boolean;\n  private includeCopilotActionable: boolean;\n\n  constructor(config: CopilotTaskConfig) {\n    this.instructions = config.instructions;\n    this.functions = config.actions || [];\n    this.includeCopilotReadable = config.includeCopilotReadable || true;\n    this.includeCopilotActionable = config.includeCopilotActionable || true;\n  }\n\n  async run(context: CopilotContextParams, data?: T): Promise<void> {\n    const entryPoints = this.includeCopilotActionable ? Object.assign({}, context.entryPoints) : {};\n\n    // merge functions into entry points\n    for (const fn of this.functions) {\n      entryPoints[fn.name] = fn;\n    }\n\n    let contextString = \"\";\n\n    if (data) {\n      contextString = (typeof data === \"string\" ? data : JSON.stringify(data)) + \"\\n\\n\";\n    }\n\n    if (this.includeCopilotReadable) {\n      contextString += context.getContextString([], defaultCopilotContextCategories);\n    }\n\n    const systemMessage: Message = {\n      id: \"system\",\n      content: taskSystemMessage(contextString, this.instructions),\n      role: \"system\",\n    };\n\n    const messages = [systemMessage];\n\n    const response = await fetchAndDecodeChatCompletion({\n      copilotConfig: context.copilotApiConfig,\n      messages: messages,\n      tools: context.getChatCompletionFunctionDescriptions(entryPoints),\n      headers: context.copilotApiConfig.headers,\n      body: context.copilotApiConfig.body,\n    });\n\n    if (!response.events) {\n      throw new Error(\"Failed to execute task\");\n    }\n\n    const reader = response.events.getReader();\n    let functionCalls: FunctionCall[] = [];\n\n    while (true) {\n      const { done, value } = await reader.read();\n\n      if (done) {\n        break;\n      }\n\n      if (value.type === \"function\") {\n        functionCalls.push({\n          name: value.name,\n          arguments: JSON.stringify(value.arguments),\n        });\n        break;\n      }\n    }\n\n    if (!functionCalls.length) {\n      throw new Error(\"No function call occurred\");\n    }\n\n    const functionCallHandler = context.getFunctionCallHandler(entryPoints);\n    for (const functionCall of functionCalls) {\n      await functionCallHandler(messages, functionCall);\n    }\n  }\n}\n\nfunction taskSystemMessage(contextString: string, instructions: string): string {\n  return `\nPlease act as an efficient, competent, conscientious, and industrious professional assistant.\n\nHelp the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.\nAlways be polite and respectful, and prefer brevity over verbosity.\n\nThe user has provided you with the following context:\n\\`\\`\\`\n${contextString}\n\\`\\`\\`\n\nThey have also provided you with functions you can call to initiate actions on their behalf.\n\nPlease assist them as best you can.\n\nThis is not a conversation, so please do not ask questions. Just call a function without saying anything else.\n\nThe user has given you the following task to complete:\n\n\\`\\`\\`\n${instructions}\n\\`\\`\\`\n`;\n}\n"],"mappings":"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","names":["import_react","React","import_react","import_nanoid","import_react","setsHaveIntersection","import_react","import_react","import_shared","import_nanoid","import_shared","messages","import_react","import_nanoid","import_react","import_react","import_react","import_shared","defaultSystemMessage","messages","error"]}